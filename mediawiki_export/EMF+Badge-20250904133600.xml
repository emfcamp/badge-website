<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.11/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.11/ http://www.mediawiki.org/xml/export-0.11.xsd" version="0.11" xml:lang="en">
  <siteinfo>
    <sitename>EMF Badge</sitename>
    <dbname>badgewiki</dbname>
    <base>https://badge.emfcamp.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.39.6</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">EMF Badge</namespace>
      <namespace key="5" case="first-letter">EMF Badge talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Badge16 Ideas</title>
    <ns>0</ns>
    <id>10</id>
    <revision>
      <id>28</id>
      <parentid>27</parentid>
      <timestamp>2015-05-21T16:44:59Z</timestamp>
      <contributor>
        <username>Mbrejza</username>
        <id>5</id>
      </contributor>
      <minor/>
      <origin>28</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1975" sha1="sxgkgv1mn40at883m89g1dxwl49hlg1" xml:space="preserve">
== Software ==
*Interpreter for high level functionality
*microPython / eLUA - run 'out of the box' on several microcontrollers. Would just require HAL c code for access to peripherals
**Would allow users to run their own code on the badge without any additional software on their PCs. micropython appears as mass storage or via a terminal on USB
*have SD card support for additional user storage

== User Interface (Screen Options) ==
*'low res' black &amp; white LCD (as 2014)
**can be seen during the day without a backlight
**backlight needed at night (~10mA)
**good outside contrast
*'high res' colour TFT LCD
**higher resolution and colour adds to experience
**backlight needed all the time (can be dimmed in low light)
**contrast is poor in daylight
**cost about the same as the mono LCD
**'transflective' modules with improved daylight contrast available, but likely increased cost


== Wireless Network ==
*Downloading camp info
*Can be used to obtain badge location based on RSSI
*send messages to friends
*ask for friends location
*sensor network
**combine with location to map temperatures and so on over the weekend
*potential parts - MRF89XA (3mA rx current, 868MHz, 10mW)


== Other peripherals ==
*IR for sharing between badges
**can share python/LUA scripts, contact details
**used to 'friend people' to share messages via the radio
*accelerometer to go into low power mode when put down
**eg MMA8652 (40p)
*buzzer/speaker for notifications (and general use)


== Power supply ==
*ideally would last the weekend (60 hours)
*single AA
**standard alkaline - 2.5Whr  (~15mA average at 3.3V)
**lithium AA - 4.5Whr (~25mA average at 3.3V)
*lipo
**2014 lipo ~4Whr
**requires charging circuitry
**ideally wants a hard back to prevent damage
**increased cost

== Hackability ==
*conductive thread pads next to lanyard
**supply little bags of LEDs and thread for say ¬£2
*extra GPIO broken out
**ardiuno footprint?
*python/LUA would allow for beginners to hack the badge</text>
      <sha1>sxgkgv1mn40at883m89g1dxwl49hlg1</sha1>
    </revision>
  </page>
  <page>
    <title>Badge Competition 2016</title>
    <ns>0</ns>
    <id>46</id>
    <revision>
      <id>248</id>
      <parentid>246</parentid>
      <timestamp>2016-10-02T16:24:12Z</timestamp>
      <contributor>
        <username>Jonty</username>
        <id>45</id>
      </contributor>
      <origin>248</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="566" sha1="nbfd6tdr7w8gjfepqh9xktkq73hq6av" xml:space="preserve">We're running a competition for the best use of the TiLDA Mk3 badge from EMF 2016. We'll award a prize in two categories: software and hardware.

The prize in both categories will be '''two tickets to EMF 2018''' (plus the 2017 one-day event if it happens), with the runners up getting another TiLDA Mk3 badge.

==Entering==

All apps [http://api.badge.emfcamp.org/ submitted to the app library] will be considered for the competition. If your entry can't be uploaded to the library, drop us an email at badge@emfcamp.org.

Entries will close on December 31st, 2016.</text>
      <sha1>nbfd6tdr7w8gjfepqh9xktkq73hq6av</sha1>
    </revision>
  </page>
  <page>
    <title>Main Page</title>
    <ns>0</ns>
    <id>1</id>
    <revision>
      <id>481</id>
      <parentid>480</parentid>
      <timestamp>2024-03-18T20:45:46Z</timestamp>
      <contributor>
        <username>Sknebel</username>
        <id>64</id>
      </contributor>
      <comment>float-right TOC instead</comment>
      <origin>481</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3699" sha1="110a929wtbbpn1x9h382i2jt5n4mtjb" xml:space="preserve">The aim of the EMF badge is to give people interesting hardware they've probably not experimented with before while being simple enough that anyone can play with it.
&lt;div style="float:right"&gt;__TOC__&lt;/div&gt;
==Contacting the badge team==

* email: '''badge@emfcamp.org'''
* irc: '''irc.libera.chat #emfcamp-badge'''
* matrix: '''[https://matrix.to/#/#badge:emfcamp.org #badge:emfcamp.org]

==EMF2024 - Tildagon==
'''[https://tildagon.badge.emfcamp.org/ Tildagon preliminary documentation]'''

Announcement blog post: '''[https://blog.emfcamp.org/2024/03/18/tildagon/  Tildagon: The EMF 2024+ badge]'''

&lt;blockquote&gt;Introducing the Tildagon: A reusable badge with modular components upgraded at each event, and hexpansion slots to fill with your own creations.&lt;/blockquote&gt;




==EMF2022 - TiDAL==

'''[[TiDAL|TiDAL documentation main page]].'''

'''[https://2022.badge.emfcamp.org App store hatchery].'''

==EMF2018 - TiLDA MkŒ¥==
[[File:TiLDA_Mk4_Front_with_sponsors.png|right|thumb|TiLDA Mkùõø|link=TiLDA_MK4]]

'''[[TiLDA_MK4|TiLDA MkŒ¥ main page]].'''

2018 badge announcement on our blog&lt;br/&gt;

http://blog.emfcamp.org/post/177423823788/tilda-mk4-the-emf-2018-badge
&lt;div style="clear: both"&gt;&lt;/div&gt;

==EMF2016 - TiLDA MkœÄ==
[[File:TiLDA_MK3_front.jpg|right|thumb|TiLDA MkœÄ|link=TiLDA_MK3]]

[[TiLDA_MK3]] main page.

2016 badge announcement on our blog&lt;br/&gt;

http://blog.emfcamp.org/post/144514906298/tilda-mkœÄ-the-hackable-conference-badge-that

Update, we have sponsors, the badge is saved!

http://blog.emfcamp.org/post/145667126793/the-emf-tilda-badge-is-saved
&lt;div style="clear: both"&gt;&lt;/div&gt;
==EMF2014 - TiLDA MKe==
[[File:Tumblr_inline_n9znh3W5tC1rpuop0.jpg|right|thumb|TiLDA MKe]]

The [[TiLDA MKe|TiLDA MKe project]] is code named "ElectroMagnetic Boogaloo"

The MKe is an entirely new design, based on the Arduino Due.  It brings an LCD display, Accelerometer and Gyro, along with a long-range wireless transceiver.  The original specification was to give people live schedule updates and camp notifications, but the hardware was capable of much more.

Please Note: There are a couple of minor hardware and some firmware issues with the MKe that might be effecting your badge. If you've let the magic smoke out of your charge controller or have tried to re-flash and ended up with nothing but a couple of dimly glowing lights then DO NOT DESPAIR -It's recoverable and fixes, documentation and lots of firmware are still being produced :)
&lt;div style="clear: both"&gt;&lt;/div&gt;

==EMW2013 - SiNE==
[[File:800px-SiNE_Front_Angle.JPG|thumb|300px]]
[[SiNE|SiNE: Investigating the Neighbourhood of EMW]]

Each attendee of Electromagnetic Wave received a SiNE badge, allowing them to take part in a treasure hunt based around the boat. By solving the clues, attendees were directed to an object or location either on or near the Stubnitz. The clue letter was also the first letter of the answer - large matching letters fitted with IR code transmitters were stored at each location. Holding your badge in front of the letter lit the corresponding light on a badge, allowing the user to collect them all!

&lt;div style="clear: both"&gt;&lt;/div&gt;

==EMF2012 - TiLDA MK1==
[[File:Emf2012_badge_pcb.png|thumb|300px]]&lt;br/&gt;
[http://wiki-archive.emfcamp.org/2012/articles/b/a/d/Badge.html TiLDA]&lt;br/&gt;
The first EMF camp badge, base around the Arduino Leonard, with on board IR, NRF24 Radio and RGB LED's.&lt;br/&gt;
[http://blog.emfcamp.org/post/28558155390/revealing-tilda-our-camp-badge Revealing TiLDA, our camp badge!]

&lt;div style="clear: both"&gt;&lt;/div&gt;

==[[Team:Badge|Badge Team]]==

The badge team is being headed by 
*[[User:Dpslwk|'RepRap' Matt]] from Nottinghack
*[[User:thinkl33t|Bob]] from Hackspace Manchester</text>
      <sha1>110a929wtbbpn1x9h382i2jt5n4mtjb</sha1>
    </revision>
  </page>
  <page>
    <title>SiNE</title>
    <ns>0</ns>
    <id>2</id>
    <revision>
      <id>266</id>
      <parentid>265</parentid>
      <timestamp>2017-05-09T15:55:01Z</timestamp>
      <contributor>
        <username>Jonty</username>
        <id>45</id>
      </contributor>
      <origin>266</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5400" sha1="4ptlx3fqx2y56edbagvit38ht5m6rop" xml:space="preserve">[[File:800px-SiNE_Front_Angle.JPG|thumb|300px]]
==About SiNE==
SiNE: Investigating the Neighbourhood of EMW&lt;br /&gt;
Each attendee of Electromagnetic Wave receives a SiNE badge which has two purposes; firstly it allows you to take part in a treasure hunt based around the boat. By solving the clues you will be directed to an object or location either on or near the Stubnitz. The clue letter is also the first letter of the answer - when you arrive at the correct location you will find a large matching letter. Hold your badge in front of the letter, and the corresponding light on your badge will illuminate. The first person to solve all the clues and bring their fully illuminated badge to the ticket desk wins two tickets to Electromagnetic Field 2014. Anyone else solving the puzzle will be allowed to choose from a selection of prizes for as long as they last!

The second purpose of the badge is as a locator beacon - as people walk around the boat they will create a trail of the places they visit and the talks they attend. We hope to use this information to better schedule our future events. The data will be made available publicly after the event, and we'll provide a way of finding their badge identifier for those who want to get their own trail.

===Scavenger hunt===
As you locate the beacons hidden around EMWave more of your LED's will light up. To save power the LED do not stay on all the time and the beacons you have seen are flash in groups every few seconds.&lt;br /&gt;
The beacons you have seen is store in the EEPROM and so the data is preserved even if you remove the power
====Clue List====
Now EMWave has past here is the clue list: (Will add answers soon --[[User:Dpslwk|Dpslwk]] ([[User talk:Dpslwk|talk]]) 14:21, 6 May 2013 (UTC))
*A: I can't believe it's not butter!
*B: Bond would be comfortable here and he has a licence.
*C: One of your EMW badge designers.
*D: One of your EMW badge designers.
*E: Powered by Orange.
*F: ____ and aft.
*G: False patch of nature.
*H: All _____ on deck! 
*I: Initial illumination, informing incomers.
*J: Java's main export.
*K: A nautical speed, mooring the Stubnitz. 
*L: Budding safecrackers.
*M: An essential orienteering tool.
*N: A German Venus? Not exactly Botticelli!
*O: Fun times in the Emergency Room!
*P: A most unusual Landrover.
*Q: Encoded in a massive square.
*R: A lifesaver in Germany.
*S: Quite possibly the most unusual holiday home.
*T: One of your EMW badge designers. 


===Locator ID===
[[File:800px-SiNE_Front_Buttons.jpeg|thumb|300px]]
Each badge is programmed with a unique ID, that is transmitted about 5 times a second. There will be Raspberry Pi's doted around the ship, collecting data.&lt;br /&gt;
EMF will not know your badge ID, as there are handed out at random. &lt;br /&gt;
A badge's ID is shown on the LED using binary encoding.
This is done at power up, or by pressing and holding the "ID" button&lt;br /&gt;

If you '''do not''' wish to have your badge trasnmitting an ID you can clear it by holding the "Erase" button for about 5 seconds.

The badge ID is 9 bit's long, these are displayed across the A-I LED's, a lit LED is 1 and unlit is 0, LSB first.&lt;br /&gt;
Example if LED's A D E and H are lit then we have 010011001 in binary or 0x099 in HEX or 153 in decimal.

Unfortunately due to a lack of time the Raspberry Pi's were never setup, as so no data was collected.

&lt;div style="clear: both"&gt;&lt;/div&gt;

==Sponsors==
[[File:800px-SiNE_Back_Angle.JPG|thumb|300px]]
SiNE was only possible thanks to our sponsors:
* [http://www.twilio.com Twilio] A Cloud communications company sponsored the parts need to make badges.
* [http://ciseco.co.uk Ciseco] A Nottingham based electronics company that make low power wireless radios, donated the time to build the badges on there SMT assemble line.
&lt;div style="clear: both"&gt;&lt;/div&gt;

===DevBoards===
[[File:DevBoards.JPG|thumb|300px]]
Before designing the final SiNE badge we built three development boards, not bothered about the looks, they were built to test the hardware and wiring between the parts. &lt;br /&gt;
Once it was confirmed that the parts worked together they were passed onto the software developer to start work on the code need for the scavenger hunt and location tracking. &lt;br /&gt;
Using these development boards meant the software was ready to go around the same time as the final badges were produced.

&lt;div style="clear: both"&gt;&lt;/div&gt;
==Badge Hacking==
[[File:800px-SiNE_Schematic.png|thumb|300px]]
We actively encourage users to hack there badge better and hope the information provided below will help

===Flashing and Fuses===
We use avrdude and an ISP programer to flash the ATTiny44A
Example command lines can be found in the Makefile in the SiNE-Firmware github

avrdude part flag (-p) is t44

Fuses:
* Low: 0xC2
* High 0xD7
* Extended: 0xFF

===Components===
The following parts were used: (data-sheet links to come)
* ATTiny44A - MCU running all the code
* 74HCT164AD - Shift register connecting the matrix of LED's
* LED's - 20 0805 LED's for each of the hidden locations
* IR Receiver - listening for the unique ID of each of the hidden beacons
* IR Sender - sending out the badges ID for Location tracking
* 2032 Coin Cell - Power for the day and possible more 
* ISP header - Used for programming of the ATTiny44A

===Resources===
* [https://github.com/EMF-TiLDA/SiNE-PCB PCB]
* [https://github.com/EMF-TiLDA/SiNE-Firmware Firmware]

[[Category:Badges]]</text>
      <sha1>4ptlx3fqx2y56edbagvit38ht5m6rop</sha1>
    </revision>
  </page>
  <page>
    <title>TiDAL</title>
    <ns>0</ns>
    <id>82</id>
    <revision>
      <id>478</id>
      <parentid>475</parentid>
      <timestamp>2022-06-19T18:39:47Z</timestamp>
      <contributor>
        <username>0x47df</username>
        <id>83</id>
      </contributor>
      <comment>link hardware repository</comment>
      <origin>478</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="543" sha1="maf4t8295khiwwuowa818u6qjpp2l9d" xml:space="preserve">To do an OTA Update and get the latest firmware make sure your battery is charged!

You may have to get very close to an access point (within a couple of metres) for the WiFi to work. Sorry! The more busy an access point is, the more difficulty the TiDAL badge will have communicating.

* Documentation https://github.com/emfcamp/tidal-docs
* Firmware Repository https://github.com/emfcamp/TiDAL-Firmware
* Hardware Repository https://github.com/emfcamp/TiDAL-Hardware
* Flyer https://usercontent.irccloud-cdn.com/file/tRv4Lyv4/badge+flyer.pdf</text>
      <sha1>maf4t8295khiwwuowa818u6qjpp2l9d</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3</title>
    <ns>0</ns>
    <id>12</id>
    <revision>
      <id>464</id>
      <parentid>284</parentid>
      <timestamp>2021-05-26T08:16:24Z</timestamp>
      <contributor>
        <username>Thinkl33t</username>
        <id>2</id>
      </contributor>
      <origin>464</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7550" sha1="odrthxysonfp0cjk6saia6pyslb5bky" xml:space="preserve">[[File:TiLDA_MK3_front.jpg|right|500px|TiLDA MkœÄ]]

== Using your badge ==

&lt;div style="background-color: #FFFFDD; border: 1px solid #808000; padding: 5px;"&gt;&lt;strong&gt;If you just got your badge and it doesn't do anything&lt;/strong&gt;, don't despair, quite a few of them need to be [[TiLDA_MK3/reset|factory reset]] before showing the loading screen. Press and hold &lt;code&gt;MENU&lt;/code&gt; while quickly pressing the reset button at the back. Keep the &lt;code&gt;MENU&lt;/code&gt; button hold for another 2 seconds while the green light on the front is blinking. Release it &lt;i&gt;while&lt;/i&gt; the green light &lt;b&gt;and&lt;/b&gt; the screen back light is on. If you got it correct the red light should flash.&lt;br&gt;If this doesn't work you can [[TiLDA_MK3/Firmware_Update|update the badge firmware]]. If this doesn't work, please come and join us in #emfcamp-badge on [https://libera.chat/ Libera IRC]&lt;/div&gt;


&lt;div style="background-color: #DDFFFF; border: 1px solid #808000; padding: 5px;"&gt;If you're having problems downloading some apps from the App Library &lt;b&gt;please update your badge via the App Library update option&lt;/b&gt;. After a restart it should work much smoother.&lt;/div&gt;

=== Assembly ===
With your badge you will receive a booklet explaining how it's done. If you have any problems, please come to the Badge Operation Center and we will help you.

=== Basic usage ===
After you have assembled your badge you can just use the tiny switch at the bottom of the screen to turn your badge on. Alternatively you can use any USB power source. If you turn your badge on for the first time (or if for some reason it has reset itself) you will get some on-screen information while we try to download the newest set of software. 

If at any point you want to restart your badge you can just press the reset button at the back. 

==== Changing your name ====

# Press 'Menu'
# Select the 'Change Name' app and press 'A'
# Use the joystick and 'A' key to enter your name
# Press 'Menu' to save your name and reset the badge - your name should now be displayed!

==== Installing new apps ====

# Press 'Menu'
# Select the 'App Library' app and press 'A'
# Select "Browse App Store"
# Select a category and then an app. Wait until you see the description and press "A" to save it.
# Press B a few times (or alternatively MENU) to restart your badge
# On the home screen you can now press MENU and select "View all" to find your newly installed app. If you want to pin it to the quick launcher screen select your app and press MENU. If you just want to start it press A instead.

=== WiFi ===
Your TiLDA Badge has built-in wifi support. It should all just work if you're at the campsite, but if you're on your own network you might have to tell the badge about it. For more information please have a look here: [[TiLDA MK3/wifi|WiFi]]

&lt;strong&gt;A word of warning&lt;/strong&gt;: During EMF the badge will use "emf-insecure". This is, as the name implies, not the most secure way of transmitting data. On top of that there are some problems with HTTPS and SSL, so we're not using it for with the default apps (we're working on it!). Please &lt;span style="color:red"&gt;don't send anything private or important to or from the badge via wifi&lt;/span&gt;.

=== Charging ===
The badge charges via a microUSB socket, and takes about 2-3 hours for a full charge. The red charge LED next to the USB connector will extinguish when charging is complete

=== Nothing works! Help! ===

Don't worry, you can always "factory reset" your badge. Please follow these instructions: [[TiLDA_MK3/reset|Resetting]]

If everything else absolutely fails, you can try following these instructions (advanced): [[TiLDA_MK3/Firmware_Update]]

== Hacking your badge ==


'''[[TiLDA_MK3/Introduction_to_badge_hacking|Badge Hacking Workshop Documentation]]'''


One of the main goals of TiLDA is to make hacking it as easy as possible. All you need to do so is a computer with USB and your badge.

* '''[[TiLDA MK3/Get Started|Step-by-step: How to get started]]''' 
* '''[[TiLDA MK3/Run Code|3 Ways to run code on your TiLDA]]''' 
* [[TiLDA MK3/App Store Submissions|App Store Submissions]]

The badge itself runs code written in the computer language [https://en.wikipedia.org/wiki/Python_(programming_language) Python] which is run by a bit of software called [https://micropython.org/ Micropython]. 

For more information about the functions available please have a look at the [[#Badge API|Badge API]] section of this page.

If you're already familiar with all this you can jump right into the topic of Apps. Apps can be shared via the EMF App Library or by copying files of and on via USB. If you want to know more about how this works go to [[TiLDA MK3/apps]]

In case you're more interested in what makes the hardware tick and your confident with C++ and microprocessors then you can work directly with the micropython code that runs TiLDA: [[TiLDA MK3/build|How to build the firmware from scratch]]

All code used is hosted on Github. Contributions and PR are very welcome!
* https://github.com/emfcamp/micropython
* https://github.com/emfcamp/Mk3-Firmware
* https://github.com/emfcamp/Mk3-Server

=== Some ideas ===

[[TiLDA MK3/Ideas|Please share what you've done (or want to do) with others!]]

[https://github.com/emfcamp/Mk3-Hardware/blob/master/case-final.dxf Laser cut case files]

The files used in the '''Fab Lab Truck''' for lasercutting are available here: http://www.thingiverse.com/thing:1707973

== Badge API ==

=== Build-in ===
* [http://docs.micropython.org/en/latest/pyboard/ documentation] - General Micropython libarary
* [[TiLDA MK3/ugfx|uGFX]] - The TiLDA LCD colour screen
* [[TiLDA MK3/documentation/cc3100|CC3100]] - The wifi chip
* [[TiLDA MK3/rtc|RTC]] (real time clock)
* [[TiLDA MK3/adc|ADC]] (analogue reading)
* [[TiLDA MK3/timer|Timer]]
* Microcontroller peripherals [https://docs.micropython.org/en/latest/pyboard/library/pyb.html] (Timers, PWM, serial, [[TiLDA MK3/spi|SPI]] etc)

=== TiLDA Libraries ===
On top of the build-in modules above we have also created a bunch of helpful libraries written in python. If you go through the bootstrap process or use the App Library you should always have a full set of those on your badge. If for some reason this isn't the case you can download our repository from https://github.com/emfcamp/Mk3-Firmware and copy the &lt;code&gt;lib&lt;/code&gt; folder onto your badge.

TBD, for now please have a look at the libraries themselves: https://github.com/emfcamp/Mk3-Firmware/tree/master/lib

* [[TiLDA MK3/lib/buttons|buttons]]
* database
* dialogs
* filesystem
* http_client
* imu
* wifi
* NTP Example: https://gist.github.com/drrk/4a17c4394f93d0f9123560af056f6f30
* On board LED "[[TiLDA MK3/NeoPixel|NeoPixel]]" example: https://github.com/mayhem/tilda-mk3-led-demo

Full hardware files are on GitHub [https://github.com/emfcamp/Mk3-Hardware]

(feel free to add additional ideas, and create links new wiki pages to on-going projects, perhaps someone will want to contribute)

== Badge hardware ==
TiLDA comes with a long list of very useful hardware. Some might be obvious, but some are a bit hidden. 
* Colour LCD screen 320x240
* Joystick and A/B/Menu Buttons
* Wifi (cc3100)
* Accelerometer
* Compass
* Buzzer
* Battery
* &lt;s&gt;WS2812B aka "Neo Pixel"&lt;/s&gt; on port PB13. [https://badge.emfcamp.org/wiki/TiLDA_MK3/How_to_fix_NeoPixel Sadly defunct]
* MicroSD slot

Harware files are available on GitHub [https://github.com/emfcamp/Mk3-Hardware].

NOTE: The WS2812B is actually on pin PB13, not X2 as shown below!

[[File:pinout-1.png | 500px]] [[File:pinout2-1.png | 500px]]</text>
      <sha1>odrthxysonfp0cjk6saia6pyslb5bky</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/</title>
    <ns>0</ns>
    <id>75</id>
    <revision>
      <id>400</id>
      <parentid>399</parentid>
      <timestamp>2018-09-02T09:33:29Z</timestamp>
      <contributor>
        <username>Finnn</username>
        <id>52</id>
      </contributor>
      <minor/>
      <origin>400</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="49" sha1="7xxlx3x37md0dv46ko6w5v3r3s5ncf6" xml:space="preserve">You are looking for the root page; [[TiLDA_MK3]].</text>
      <sha1>7xxlx3x37md0dv46ko6w5v3r3s5ncf6</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/adc</title>
    <ns>0</ns>
    <id>21</id>
    <revision>
      <id>255</id>
      <parentid>110</parentid>
      <timestamp>2017-03-02T00:50:40Z</timestamp>
      <contributor>
        <username>Claude</username>
        <id>47</id>
      </contributor>
      <comment>fix broken link to micropython adc docs</comment>
      <origin>255</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1104" sha1="tbryjbcunslkryw54xf5il4q4k269c9" xml:space="preserve">See here [https://docs.micropython.org/en/latest/pyboard/library/pyb.ADC.html] for the main micropython documentation.

All ADC readings are referenced to the supply rail, which is about 3.3V. To increase the ADC accuracy, the internal voltage reference can be read, and used to offset variations in the supply rail.

&lt;pre&gt;
adcin = pyb.ADC(channel_to_read).read()
ref_reading = pyb.ADC(0).read()
supply_voltage = 4095/ref_reading*1.21  # or change 1.21 with the calibrated value - see below
adc_voltage =  adcin / 4095 * supply_voltage
&lt;/pre&gt;

Note, the factory reads the internal reference with a supply voltage of 3.0V, and stores this reading. This can then be used to get the actual voltage reference. For example
&lt;pre&gt;
import stm
factory_reading = stm.mem16[0x1FFF75AA]
reference_voltage = factory_reading/4095*3   # will be approximately 1.21V
&lt;/pre&gt;

For convenience, the library `onboard' provides the following functions for reading the battery voltage, unregulated voltage, or light level
&lt;pre&gt;
import onboard
onboard.get_battery_voltage()
onboard.get_unreg_voltage()
onboard.get_light()
&lt;/pre&gt;</text>
      <sha1>tbryjbcunslkryw54xf5il4q4k269c9</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3 API</title>
    <ns>0</ns>
    <id>17</id>
    <revision>
      <id>46</id>
      <parentid>45</parentid>
      <timestamp>2016-07-13T14:51:58Z</timestamp>
      <contributor>
        <username>Marekventur</username>
        <id>10</id>
      </contributor>
      <origin>46</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="833" sha1="l4vuyeu8i04rvc1xjwyesirpmj32qky" xml:space="preserve">=== GET api-badge.emf.camp/apps.json ===
&lt;pre&gt;
{
    "games": [
        {
            user: "someuser"
            name: "snake",
            description: "Some game with a snake",
            files: {
                "main.py": "abcdefgh",
                "images.bmp": "abcdefg"
            }
        },
        {
            user: "someuser2"
            name: "tetris",
            description: "Some game with a snake",
            files: {
                "main.py": "abcdefgh",
                "images.bmp": "abcdefg"
            }
        }
    ],     
    "emf": [...]
    ...    
}
&lt;/pre&gt;


=== GET api-badge.emf.camp/someuser/snake.json ===
&lt;pre&gt;
{
    user: "someuser"
    name: "snake",
    description: "Some game with a snake",
    files: {
        "main.py": "abcdefgh",
        "images.bmp": "abcdefg"
    }
}
&lt;/pre&gt;</text>
      <sha1>l4vuyeu8i04rvc1xjwyesirpmj32qky</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/apps</title>
    <ns>0</ns>
    <id>18</id>
    <revision>
      <id>401</id>
      <parentid>50</parentid>
      <timestamp>2018-09-02T09:35:45Z</timestamp>
      <contributor>
        <username>Finnn</username>
        <id>52</id>
      </contributor>
      <origin>401</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="129" sha1="nr6y2wzgovarwq16nxuoszk4eg7th2w" xml:space="preserve">ToDo: How to create, test and publish apps

This section is defunct, but [[TiLDA_MK3#Hacking_your_badge]] will probably help you.</text>
      <sha1>nr6y2wzgovarwq16nxuoszk4eg7th2w</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/apps/nmap</title>
    <ns>0</ns>
    <id>33</id>
    <revision>
      <id>173</id>
      <timestamp>2016-08-06T12:40:26Z</timestamp>
      <contributor>
        <username>Lilafisch</username>
        <id>17</id>
      </contributor>
      <comment>create page for tilda nmap app</comment>
      <origin>173</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="286" sha1="fs8gwu95w6nfbbtwd5j8340uro8xd3n" xml:space="preserve">== Description ==

you will see a map with 
circles representing the wifi access points you see.
The better the reception for an access point, the larger the diameter of the circle.

Based on this information, you can estimate where you are!

github: https://github.com/muccc/tilda-nmap</text>
      <sha1>fs8gwu95w6nfbbtwd5j8340uro8xd3n</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/App Store Submissions</title>
    <ns>0</ns>
    <id>35</id>
    <revision>
      <id>183</id>
      <parentid>182</parentid>
      <timestamp>2016-08-07T09:49:02Z</timestamp>
      <contributor>
        <username>Marekventur</username>
        <id>10</id>
      </contributor>
      <comment>/* How to submit */</comment>
      <origin>183</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="774" sha1="4wid5fj1419ef5j1llslkexwtxnx363" xml:space="preserve">== How to submit ==
Zip your folder up, sign up to http://api.badge.emfcamp.org/, create a new app and publish it

== Common Problems ==
Please check these things before publishing your app:
* Your app will end up in "app/username~appname", so please make sure all you paths are using that. Example: &lt;code&gt;open("app/myname~myapp/some.json")&lt;/code&gt;
* Please make sure the meta data at the top of the file is ok
* Please make sure to use &lt;code&gt;ugfx.init()&lt;/code&gt; and &lt;code&gt;buttons.init()&lt;/code&gt;, it makes it easier for me to review

Besides those, there are currently problems with apps that have too many files (lots of images for example) or use too much memory (big arrays). If it's possible in any way, please try to keep both down. We're working on reducing memory usage.</text>
      <sha1>4wid5fj1419ef5j1llslkexwtxnx363</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/build</title>
    <ns>0</ns>
    <id>14</id>
    <revision>
      <id>269</id>
      <parentid>268</parentid>
      <timestamp>2017-08-25T22:30:56Z</timestamp>
      <contributor>
        <username>Raj</username>
        <id>23</id>
      </contributor>
      <comment>/* USB Permissioning on Linux */ - spelling error</comment>
      <origin>269</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3435" sha1="2h7kzghj6gc1p6732i1algsckak60cf" xml:space="preserve">== Dependencies ==

You can use either windows or linux, although windows will not have most things installed by default

=== git, make, python, etc ===
I will just assume you have this

=== arm-none-eabi-gcc ===
https://launchpad.net/gcc-arm-embedded/+download
You will have to make the arm-none-eabi-gcc from the bin directory available to your system (add to PATH, symlink or copy)

On Ubuntu you can follow these instructions: https://launchpad.net/~team-gcc-arm-embedded/+archive/ubuntu/ppa

On Debian (in Stretch, maybe earlier versions too, also Raspbian Jessie) you can `sudo apt-get install gcc-arm-none-eabi`

=== pyusb===
&lt;pre&gt;sudo pip install pyusb&lt;/pre&gt;

== USB Permissioning on Linux ==

On some Linux distributions it may be necessary to add additional udev rules in order to allow the REPL to work:

copy the following text to /etc/udev/rules.d/49-tilda-mk3.rules

&lt;pre&gt;
# 0483:df11 - Tilda Mk3 based on Micropython board
ATTRS{idVendor}=="0483", ATTRS{idProduct}=="df11", ENV{ID_MM_DEVICE_IGNORE}="1"
ATTRS{idVendor}=="0483", ATTRS{idProduct}=="df11", ENV{MTP_NO_PROBE}="1"
SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="df11", MODE:="0666"
KERNEL=="ttyACM*", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="df11", MODE:="0666"
&lt;/pre&gt;

And then restart the udev service:

&lt;pre&gt;
sudo udevadm control --reload-rules
&lt;/pre&gt;

== Flashing ==

&lt;pre&gt;
# Clone this repo
git clone --recursive https://github.com/emfcamp/micropython.git 

# Switch to our work branch
cd micropython
git checkout tilda-master

# Now we can build the firmware and flash it to the badge
# You have to boot the badge into dfu mode by pressing down the center
# joystick button while pressing the reset button to trigger a reboot
make -C stmhal BOARD=STM32L475_EMFBADGE deploy
&lt;/pre&gt;

== What to do when the firmware update.py script fails ==

When attempting an update from linux, some users have hit timeouts during hte mass_erase step. This leaves the badge in an ususable state.

&lt;pre&gt;
$ python update.py 
Hello - Welcome to the automated TiLDA firmware updater
We found your badge. So far, so good...
Traceback (most recent call last):
  File "update.py", line 556, in &lt;module&gt;
    main()
  File "update.py", line 530, in main
    mass_erase()
  File "update.py", line 114, in mass_erase
    "\x41", __TIMEOUT)
  File "/usr/local/lib/python2.7/dist-packages/usb/core.py", line 1043, in ctrl_transfer
    self.__get_timeout(timeout))
  File "/usr/local/lib/python2.7/dist-packages/usb/backend/libusb1.py", line 883, in ctrl_transfer
    timeout))
  File "/usr/local/lib/python2.7/dist-packages/usb/backend/libusb1.py", line 595, in _check
    raise USBError(_strerror(ret), ret, _libusb_errno[ret])
usb.core.USBError: [Errno 110] Operation timed out
&lt;/pre&gt;

If you have access to a Windows PC, you can download the STMicroelectronics DfuSe USB device firmware updater software http://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-programmers/stsw-stm32080.html and use the 'Upgrade or Verify Action' part of the GUI to update the firmware instead. 

* Install the STMMicroelectronics util from the link above.
* Download the firmware.dfu file from https://update.badge.emfcamp.org/firmware.dfu and save it off.
* Start up DfuSeDemo.exe, and click the 'Choose' button - select the firmware.dfu file and then hit 'Upgrade'
* Your badge should now be un-bricked</text>
      <sha1>2h7kzghj6gc1p6732i1algsckak60cf</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/Firmware Update</title>
    <ns>0</ns>
    <id>38</id>
    <revision>
      <id>410</id>
      <parentid>267</parentid>
      <timestamp>2018-09-02T13:36:54Z</timestamp>
      <contributor>
        <username>Rabble</username>
        <id>66</id>
      </contributor>
      <origin>410</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4118" sha1="298pwr4o8o0s7nisz5c4fp168ivvda3" xml:space="preserve">== Update your Tilda Mk3==

This guide will help you to update your Tilda Mk3 badge. Be careful, following these instructions will delete all files and setting on your badge, so make sure you have copies of everything!

If you're having trouble following these instructions or updating your badge, [mailto:badge@emfcamp.org please get in touch] and we'll do our best to help.

== Before you start==

You need to put your badge into DFU mode. This activates a USB bootloader stored in ROM on the STM32 processor.

'''To enter DFU mode:''' Switch on the badge. Press the center joystick button while at the same time quickly pushing the reset button on the back of the badge. 

In some cases this seems to require a few attempts. You can also try unplugging the battery, and holding down the center button while plugging in USB.

==OSX==

'''Prerequisites needed for Mac OS X'''

1. XCode (from App Store)

2. Python &amp; pip
* Homebrew method
*: 1. [http://docs.python-guide.org/en/latest/starting/install/osx/ Install Homebrew and Pip]
*: 2. &lt;code&gt;brew install libusb lsusb&lt;/code&gt;
*: 3. &lt;code&gt;pip install libusb1 pyusb&lt;/code&gt;
* MacPorts method
*: 1. [http://johnlaudun.org/20150512-installing-and-setting-pip-with-macports/ Install MacPorts and Pip]
*: 2. &lt;code&gt;sudo port install usbutils py-pip&lt;/code&gt;
*:: usbutils provides e.g. lsusb, useful for knowing if the badge is connected in DFU mode
*: 3. &lt;code&gt;sudo pip install libusb1 pyusb&lt;/code&gt;

3. Check that you're connected in DFU mode:
: &lt;code&gt;lsusb&lt;/code&gt;
: Should output something like:
: &lt;code&gt;Bus 020 Device 002: ID 0483:df11 STMicroelectronics STM Device in DFU Mode&lt;/code&gt;

4. &lt;code&gt;wget https://update.badge.emfcamp.org/update.py&lt;/code&gt;

5. &lt;code&gt;sudo python update.py&lt;/code&gt;

6. To get a shell: &lt;code&gt;screen /dev/tty.usbmodem*&lt;/code&gt;

'''Troubleshooting'''

If you get the error &lt;code&gt;Error: No backend available&lt;/code&gt; then python cannot find the USB library.  Please Repeat steps 2 and 3 above, see https://github.com/walac/pyusb/issues/120 for more details.

== Linux ==

Install prerequisites if required:

&lt;code&gt;sudo apt install python-usb&lt;/code&gt;

Open a terminal and execute this line:

&lt;code&gt;curl --silent --show-error --retry 5 https://update.badge.emfcamp.org/update.py | python&lt;/code&gt;

If you get an error saying &lt;code&gt;ImportError: No module named core&lt;/code&gt; then the python-usb package in your distribution is too old. On Debian, you should be able to fix it using pip instead:

&lt;code&gt;sudo apt install python-pip&lt;/code&gt;

&lt;code&gt;sudo pip install --upgrade pyusb&lt;/code&gt;

== Windows ==

'''&lt;span style="color:red"&gt;WARNING&lt;/span&gt;: There have been reports of badges being bricked when flashed from windows. They can be recovered using the OSX/Linux update procedure. We are looking for alternative ways of updating using Windows.'''

On a Windows PC, you will need to download the STMicroelectronics DfuSe USB device firmware updater software http://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-programmers/stsw-stm32080.html and use the 'Upgrade or Verify Action' part of the GUI to update the firmware instead.

* Install the STMMicroelectronics utility from the link above.
* Download the firmware.dfu file from https://update.badge.emfcamp.org/firmware.dfu and save it.
* With the badge plugged into the computer, hold the centre joystick button and press reset. The badge should now boot into the bootloader, and be detected as a 'STM Device in DFU Mode'.
* Start up DfuSeDemo.exe, and click the 'Choose' button - select the firmware.dfu file and then hit 'Upgrade'
* Your firmware will now be updated.

== Other Operating systems==

To update your badge please download the following script and run it via python: [https://update.badge.emfcamp.org/update.py update.py]

If you know how to flash the badge yourself you can also download the DFU binary directly: [https://update.badge.emfcamp.org/firmware.dfu firmware.dfu]

== Build your own version==

If you want to build your own version of the firmware have a look [https://badge.emfcamp.org/wiki/TiLDA_MK3/build here]</text>
      <sha1>298pwr4o8o0s7nisz5c4fp168ivvda3</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/Get Started</title>
    <ns>0</ns>
    <id>23</id>
    <revision>
      <id>285</id>
      <parentid>262</parentid>
      <timestamp>2018-07-30T17:32:33Z</timestamp>
      <contributor>
        <username>Finnh</username>
        <id>43</id>
      </contributor>
      <origin>285</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="16537" sha1="79gy8cy8zikxd29r31g9dj745x1sf5x" xml:space="preserve">= Get started =

Hacking your TiLDA badge is easy. We've written it down step by step. 

If something goes wrong, the badge can be [[TiLDA_MK3/reset|reset]] to its out-of-the-box state, so do not be concerned about breaking anything.

== 1. Connect to your computer ==
To get started you need to connect your badge to a computer. You can use any MicroUSB cable - the same type that charges most mobile phones nowadays. It doesn't matter whether the batter is plugged in or not, so don't worry about it.

== 2. Check your badge is found by your computer ==
Upon connecting the badge to a computer, it should appear as a "mass storage device" just like a USB key or an external hard disk. 

'''Important:''' Just like any other USB storage device, if you changed or copied anything on the Badge, please make sure to "eject" or "safely remove" before unplugging your badge or pressing the reset button. Otherwise you might lose all your work :(

Windows will require a driver file for the serial port, which is stored on the badge's mass storage. [https://micropython.org/resources/Micro-Python-Windows-setup.pdf More information]

== 3. Connect to your badge ==

=== Windows ===
* Please follow the instruction under the "Windows" section on this page: https://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/repl.html
* Once you've installed the driver and Putty and you've connected to your badge, press Control+C to stop the main badge app, and then you should be greeted by a line saying "Micropython"

=== OSX ===
* Click the magnifying class in the top right of your screen and type &lt;code&gt;Terminal&lt;/code&gt; followed by Enter. A white terminal window should appear.
* type &lt;code&gt;screen /dev/tty.usbmodem*&lt;/code&gt; (The * is important, so don't let it out) and hit enter
* hit &lt;code&gt;control+c&lt;/code&gt;, if an error is displayed
* You should now be greeted by a line saying "Micropython"

=== Linux ===
* Open a terminal and type &lt;code&gt;screen /dev/ttyACM0&lt;/code&gt;
* You should now be greeted by a line saying "Micropython"

=== What to do if this step doesn't work? ===
* Press the reset button at the back of your badge and try again
* Have a look at https://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/repl.html for more information

== 4. Your first line of Micropython ==
* In your terminal (next to the &gt;&gt;&gt;) type &lt;code&gt;print(1 + 1)&lt;/code&gt; followed by Enter
* You should see &lt;code&gt;2&lt;/code&gt; printed on the screen. Congratulations, you've just written your first line of micropython code!
* You can now close the terminal window (or Putty, if you're on Windows). Note: some serial terminals will not close when the badge is removed or powered off. You should close the serial terminal before plugging the badge back in, otherwise the serial terminal may not reconnect.

== 5. Download some software you'll need ==

You will be downloading some stuff now. It's probably be best if you create some folder somewhere so you don't end up with files all over your Desktop.

Note you can copy files across from your computer to the badge, reset the badge and run the files though the menu, however these instructions make things a little easier.

=== Windows ===
* Python: Go to https://www.python.org/downloads/ and download python version 3.x. After the download is finished you can install it.
* Go to https://bootstrap.pypa.io/get-pip.py and save the file into your folder
* Hold shift, right click on the folder on, and click "open command window here"
* Now type &lt;code&gt;python get-pip.py&lt;/code&gt;
* After the install was successful please type &lt;code&gt;pip install pyserial pyusb&lt;/code&gt; followed by Enter.
* If you do not wish to install python, and would rather copy files across, the command line utility RoboCopy is recommended. For example: &lt;code&gt;Robocopy.exe ./my_app/ d:/apps/my_app&lt;/code&gt;

=== OSX / Linux ===

* Python: Open a terminal and type &lt;code&gt;python --version&lt;/code&gt;. If you get a version number you're good to go, otherwise go to https://www.python.org/downloads/ and download Python version 3.x. After the download is finished you can install it.
* Go to https://bootstrap.pypa.io/get-pip.py and save the file into your folder
* Use a terminal to go to the folder you created ([http://www.macworld.com/article/2042378/master-the-command-line-navigating-files-and-folders.html this is how you do it]) and type &lt;code&gt;python get-pip.py&lt;/code&gt;
* Now type &lt;code&gt;python get-pip.py&lt;/code&gt;
* After the install was successful please type &lt;code&gt;pip install pyserial pyusb&lt;/code&gt; followed by Enter

=== Problems ===
* If you have problems install python, please use google, there are lots of good explanations out there
* For information about how to install &lt;code&gt;pip&lt;/code&gt; have a look here: https://pip.pypa.io/en/stable/installing/

== 6. (Optional) Update your badge's micropython ==
'You can skip this step', but since TiLDA is still a work in progress, it's best to update regularly. So why not do it now? It's easy, just follow the instructions here: [[TiLDA_MK3/Firmware_Update]]

== 5. Run a whole file of code ==
While you can do most things via the terminal like you just did, it's a bit easier to work on a file that you can edit. So let's do that. 
* Go to https://raw.githubusercontent.com/emfcamp/micropython/tilda-master/tools/pyboard.py and use your browser to save it as "pyboard.py" into your newly created folder
* Open a text editor. On Windows you can search for &lt;code&gt;Notepad&lt;/code&gt;, on OSX there's one called &lt;code&gt;textedit&lt;/code&gt; and if you're on Linux you can probably find one by searching for "edit". 
* Copy the following and save it as &lt;code&gt;test.py&lt;/code&gt; in your folder:
&lt;source lang="python"&gt;
print(1 + 2)
&lt;/source&gt;
* Open a terminal, navigate to the right folder (see step 5 for more info) 
** Windows: &lt;code&gt;python pyboard.py test.py --device=COM4&lt;/code&gt;   Replace COM4 with whatever port your badge installed as.
** OSX: type &lt;code&gt;python pyboard.py test.py --device=/dev/tty.usbmodem*&lt;/code&gt;
** Linux: type &lt;code&gt;python pyboard.py test.py --device=/dev/ttyACM*&lt;/code&gt;
* You should now see the your terminal showing &lt;code&gt;3&lt;/code&gt;. Your getting good at this!

'''Hint''': If you don't want the home app to start every time you can create an empty &lt;code&gt;main.py&lt;/code&gt; file in the USB folder. This will stop the boot from loading the home screen and allow you do run code on your badge undisturbed. But remember to "safely eject" the badge after writing the file and to remove it again when you want the normal behaviour back

== 7. Blink ==
So far all we've seen is the badge doing some maths and sending the result back via usb. Let's start with one of the simplest hardware device on the badge, a LED (which means "Light emitting diode") -- We want to make it blink.

Create a file called &lt;code&gt;blink.py&lt;/code&gt; and copy this bit of code into it:

&lt;source lang="python"&gt;
import pyb
led = pyb.LED(1)
led.on()
pyb.delay(500)
led.off()
pyb.delay(500)
led.on()
pyb.delay(500)
led.off()
pyb.delay(500)
led.on()
&lt;/source&gt;

Save it and use a terminal to execute it (See Step 5 - but make sure to replace the filename in the command). Have a look at your badge, you should see the tiny LED labeled "A" (It's right between the B button and the screen) flash twice before and then staying on. 

Now, let's see what the code actually does. 

&lt;source lang="python"&gt;
import pyb
&lt;/source&gt;
This line tells your badge to import the "pyb" library. It allows you to do various hardware related things with your badge (the full list is [http://docs.micropython.org/en/latest/pyboard/library/pyb.html here]). This is something very important in python, you always need to import libraries before you can use them.

&lt;source lang="python"&gt;
led = pyb.LED(1)
&lt;/source&gt;
This line uses the pyb module we've just imported and creates a LED object. The "&lt;code&gt;1&lt;/code&gt;" means we're using the first LED on the badge. Change it to "&lt;code&gt;2&lt;/code&gt;", save it and run pyboard.py again - Now the LED B should flash in green. 

The &lt;code&gt;led&lt;/code&gt; bit before the &lt;code&gt;=&lt;/code&gt; means that we're not only creating an LED object, but we're also storing it for later use. 

&lt;source lang="python"&gt;
led.on()
&lt;/source&gt;
Here we're using the reference to the LED object we've just created and calling the &lt;code&gt;.on()&lt;/code&gt; function on it. Most python objects have multiple functions you can use. In this case you can look the them up here: http://docs.micropython.org/en/latest/pyboard/library/pyb.LED.html?highlight=led

&lt;source lang="python"&gt;
pyb.delay(500)
&lt;/source&gt;
This line uses the &lt;code&gt;pyb.delay()&lt;/code&gt; function to pause the execution of our program for a while. The &lt;code&gt;500&lt;/code&gt; is a number in milliseconds and the code is stopping for half a second. We need this delay to give your eyes some time to see that the LED has turned on. Try playing with different numbers or leaving the line out altogether to get a feeling for it.

== 8. Blink forever ==
Since our original &lt;code&gt;blink.py&lt;/code&gt; script is only blinking twice it might be easy to miss. Let's fix this by blinking a bit longer:

&lt;source lang="python"&gt;
import pyb
led = pyb.LED(1)
while True:
	led.toggle()
	pyb.delay(500)
&lt;/source&gt;

Be careful to make sure you're copying the spaces in front of the last two lines as well, they're very important in Python! If you want to type them you have to use the &lt;code&gt;Tab&lt;/code&gt; key on your keyboard - It's normally on the left of your keyboard, two keys above the &lt;code&gt;Shift&lt;/code&gt; key. 

Save this code and run it via &lt;code&gt;pyboard.py&lt;/code&gt; again. You should now see the red LED blinking forever.  So what's happening here?

&lt;source lang="python"&gt;
while True:
	led.toggle()
	pyb.delay(500)
&lt;/source&gt;
This is called a "while loop" in Python. It means that a certain bit of code (the one indented by the Tab at the beginning of the line) will be repeated over and over again until a certain condition is not fulfilled anymore. In this case the condition is &lt;code&gt;True&lt;/code&gt; which is the Python-way of saying "this is always correct". Therefore the loop will repeat forever. 

&lt;code&gt;led.toggle()&lt;/code&gt; is similar to &lt;code&gt;led.on()&lt;/code&gt; and &lt;code&gt;led.off()&lt;/code&gt;, but instead of always turning the LED on or off it switches between the states. Very useful in our case!

This kind of "infinite loop" is quite useful for a lot of badge code, but often you also want to have some way of leaving the loop. Try this instead:
&lt;source lang="python"&gt;
import pyb
import buttons
buttons.init()
led = pyb.LED(1)
while not buttons.is_pressed("BTN_MENU"):
	led.toggle()
	pyb.delay(500)
&lt;/source&gt;

There are a few new things here: First we have imported a new library called &lt;code&gt;buttons&lt;/code&gt;. This library helps you with all the buttons on the badge. If you want to use buttons in your script you also have to call &lt;code&gt;buttons.init()&lt;/code&gt;, so that's what we're doing in line 3.

We have also changed the &lt;code&gt;while&lt;/code&gt; loop with a new statement &lt;code&gt;not buttons.is_pressed("BTN_MENU")&lt;/code&gt;. Like I said above, &lt;code&gt;while&lt;/code&gt; loops will go on forever while its condition is fulfilled. We have now changed the condition to be "while the MENU button is not pressed".

Try running the code. You will again get the same blinking LED, but this time you should be able to stop it by pressing the MENU button. 

== 8. Hello Screen ==

Ok, now let's try to write something on the screen. TiLDA comes with a colour screen and we can use a library called UGFX to draw on it. 

Create a &lt;code&gt;main.py&lt;/code&gt; file and put this in there:
&lt;source lang="python"&gt;
import ugfx
import buttons
import pyb

ugfx.init()
buttons.init()
ugfx.clear(ugfx.YELLOW)

ugfx.text(5, 5, "Hello World", ugfx.RED)
ugfx.fill_circle(100, 100, 30, ugfx.GREEN)
ugfx.fill_circle(200, 100, 30, ugfx.GREEN)
ugfx.area(80, 150, 140, 20, ugfx.GREEN)
ugfx.area(120, 170, 60, 20, ugfx.GREEN)
&lt;/source&gt;

If you run this file you should see a the screen turn yellow with some text and a (very simple) smiley. 

If you use the screen you have to make sure you're using &lt;code&gt;ugfx.init()&lt;/code&gt;, otherwise nothing will work. &lt;code&gt;ugfx.clear()&lt;/code&gt; is used to clear the screen (in this case with a special colour) and the next 5 lines are drawing some text and a few basic shapes. 

&lt;code&gt;ugfx.text(x, y, text, color)&lt;/code&gt; Prints some text at position (x, y) in a given colour. x and y are coordinates on the screen. x=0 and y=0 means the top-left of the screen and x=320 y=240 is the bottom right corner. Try changing the two numbers and see how the text moves around on the screen.

&lt;code&gt;ugfx.fill_circle(x, y, radius, color)&lt;/code&gt; draws a circle on the screen. 

&lt;code&gt;ugfx.area(x, y, width, height, color)&lt;/code&gt; draws a rectangle on the screen. 

There are more basic drawing operations. You can find a list of them here: [[TiLDA MK3/ugfx|uGFX]]

== 10. Your own app ==

Having to have your badge connected to your computer all the time is a bit boring. Let's make it an app, so you can carry it around!

Update your &lt;code&gt;main.py&lt;/code&gt; to look like this:

&lt;source lang="python"&gt;
### Author: Your Name
### Description: Smiley!
### Category: Tutorial
### License: MIT
### Appname : Smiley

import ugfx
import buttons
import pyb

ugfx.init()
buttons.init()
ugfx.clear(ugfx.YELLOW)

ugfx.text(5, 5, "Hello World", ugfx.RED)
ugfx.fill_circle(100, 100, 30, ugfx.GREEN)
ugfx.fill_circle(200, 100, 30, ugfx.GREEN)
ugfx.area(80, 150, 140, 20, ugfx.GREEN)
ugfx.area(120, 170, 60, 20, ugfx.GREEN)

while not buttons.is_pressed("BTN_MENU"):
	pyb.wfi()
&lt;/source&gt;

The bit at the top is a comment, it's not actually part of the code and python ignores it. It does however help us categorise the app. Make sure you update your name :)

Plug your badge in and open the USB drive. Go into the "apps" folder and create a new folder called "hello_screen". Copy your newly updated &lt;code&gt;main.py&lt;/code&gt; into there and safely eject the device. If you now press the reset button at the back of your badge it will restart normally. Wait until your name appears and press the MENU button. Go all the way to the bottom right and select "View all". Now you have to press "right" until you find the "Smiley" app. Select it and press A - You should now see your smiley.

== 11. Publish your app to the app library ==

Now that you have your own smiley app, why not share it with others? 

Find your main.py and create an archive of it. Most operating systems have something build in for that purpose. In OSX you can right click and select "Compress main.py", under Windows you can select "New &gt; Zipped folder" and drag required files into the zip; under Linux you right click the files and use "Compress...". You should now have a new file called &lt;code&gt;main.zip&lt;/code&gt; or similar. 

Go to http://api.badge.emfcamp.org/ and sign up with your email address and a password.  In the top right there's a field called "Create New App"  - Put "Smiley" into the field next to it and then click "Create". On the next screen click the "Choose File" button and select your &lt;code&gt;main.zip&lt;/code&gt;. Now press "Upload" - and you're done!

You now have to wait until we have reviewed your app to make sure it's not doing something weird and then we'll hit the "publish" button and everyone on the camp site will be able to download your newly created app to their badge. If we're not quick enough, feel free to come to the badge tent and we'll hurry the review up ;)

= Alternative ways to work with TiLDA = 

All of the python code which runs on the badge can be modified on the mass storage device, and new apps can be added this way too. Be careful when using text editors to modify files on the device, if the mass storage is not 'safely removed' before removal, corruption of the file being edited can occur.

When writing your own code, it is advised edit code on your computer, then copy it across to the badge, wait for the red 'writing' LED to go out, reset it, and run.
This way you don't need to worry about safely removing the badge each time.

To interactively run code on the badge, a python REPL can be accessed via the virtual serial port. Once you have found the serial port, use your favourite serial terminal to connect to the badge. Since the badge will be running the main software, press Ctrl+c to stop it, and the badge will display '&gt;&gt;&gt;' to indicate it is ready to receive commands.

The badge runs micropython, and as a result does not contain everything you may expect from full python. See the micropython docs in the lniks below for more information.
The badge has additional APIs, in particular for the LCD, Wifi and IMU, which are also listed below.</text>
      <sha1>79gy8cy8zikxd29r31g9dj745x1sf5x</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/How to fix NeoPixel</title>
    <ns>0</ns>
    <id>40</id>
    <redirect title="TiLDA MK3/NeoPixel" />
    <revision>
      <id>213</id>
      <timestamp>2016-08-09T21:50:30Z</timestamp>
      <contributor>
        <username>Raj</username>
        <id>23</id>
      </contributor>
      <comment>Raj moved page [[TiLDA MK3/How to fix NeoPixel]] to [[TiLDA MK3/NeoPixel]]</comment>
      <origin>213</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="32" sha1="e3uyksywx2v3hdo1haqia2b8oahrgfx" xml:space="preserve">#REDIRECT [[TiLDA MK3/NeoPixel]]</text>
      <sha1>e3uyksywx2v3hdo1haqia2b8oahrgfx</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/Ideas</title>
    <ns>0</ns>
    <id>24</id>
    <revision>
      <id>280</id>
      <parentid>179</parentid>
      <timestamp>2018-07-06T22:49:35Z</timestamp>
      <contributor>
        <username>Chrisstubbs</username>
        <id>49</id>
      </contributor>
      <origin>280</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="659" sha1="eb2xkxlm92ekul0yoku29wm0h2bp5lq" xml:space="preserve">
Here are some ideas on what to do, feel free to add your own. If you are working on a project and want some help or want to share, create a new page for the project and link it here.

== Ideas ==
=== Small things ===

- Replace snake's block colours with images

- Accelerometer ball bounce

- Network synced clock

=== Larger projects ===

- IRC relay

-Location based on wifi RSSI ( badge team are looking for someone to write a good library for this)

- [https://badge.emfcamp.org/wiki/TiLDA_MK3/Ideas/hab High altitude balloon tracker]

== apps ==

- Network Map for location approximation: [[TiLDA_MK3/apps/nmap|tilda-nmap]]

- Interactive python prompt</text>
      <sha1>eb2xkxlm92ekul0yoku29wm0h2bp5lq</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/Ideas/hab</title>
    <ns>0</ns>
    <id>55</id>
    <revision>
      <id>281</id>
      <parentid>279</parentid>
      <timestamp>2018-07-07T22:40:40Z</timestamp>
      <contributor>
        <username>Chrisstubbs</username>
        <id>49</id>
      </contributor>
      <origin>281</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="529" sha1="rhd9rlfmapy09jcfihebviwd87suopu" xml:space="preserve">
== MK3 High Altitude Balloon tracker ==

'''Goal:'''

Launch a high altitude balloon at EMF 2018 using a badge tracker.


'''Progress:'''

Tracker parameter setup app (done)

Get timer working for RTTY transmission interrupt (done)

Get SPI working with RMF22 for transmitter (done)

Get UART working for GPS

Write the tracker code

Power saving

Boot directly into tracker code (see USB mouse app code - similar idea)


'''Stretch goal:'''

Camera? SSDV?


'''More'''

[https://wiki.emfcamp.org/wiki/Village:HABville HABville]</text>
      <sha1>rhd9rlfmapy09jcfihebviwd87suopu</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/Introduction to badge hacking</title>
    <ns>0</ns>
    <id>32</id>
    <revision>
      <id>259</id>
      <parentid>195</parentid>
      <timestamp>2017-03-02T01:18:41Z</timestamp>
      <contributor>
        <username>Claude</username>
        <id>47</id>
      </contributor>
      <comment>/* Beginners Guide to Badge Hacking */ fix broken link to micropython repl tutorial</comment>
      <origin>259</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3061" sha1="ewudnyvs150z6m5sm0ckdb3k55oq9qt" xml:space="preserve">= Beginners Guide to Badge Hacking =

We're going to create an LED torch for seeing our way around the camp.

'''Soldering the LED'''

You should have received an LED and a resistor with your badge. First, grab the resistor. Bend the legs over so they fit in the holes in the board, using the resistor lead bender.

[[File:Hackpad.com_Rs7awClTQDH_p.554927_1470420913282_legbender.jpg|none]]

It doesn't matter way round the resistor goes.

[[File:Hackpad.com_Rs7awClTQDH_p.554927_1470307053798_P1010517.jpg|none]]

Flip over your board and solder the resistor in place, then trim down the legs to be flush against the board.

Next, the LED. It does matter which way round the LED goes - look for a flat side on the LED and match it up with the flat side on the board. Pull your LED out about a centimetre and bend it over a bit.

[[File:Hackpad.com_Rs7awClTQDH_p.554927_1470307470838_P1010533.jpg|none]]

Flip the board over and solder the LED into place.

'''Testing'''

Plug your badge into your laptop, and use the information on [https://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/repl.html] to connect to the usb-serial port. If you hit Ctrl-C, you drop out of the badge software, and get a REPL prompt. You can tell this is working because you'll see three &amp;gt; symbols.

Type the following at the prompt. This should turn your LED on!

 import pyb
 pin = pyb.Pin(&amp;quot;LED_TORCH&amp;quot;)
 pin.high()

Of course, thats a bit of a pain to do every time we want the LED on, so let's make an app!

'''The App'''

Your badge should have shown up as a USB drive. Open the folder '''apps''', and create a folder within it called '''torch.'''

Create a file within this called '''main.py'''. This is your app's main file. Open it in a text editor.

First, we need to tell the badge some details about your app. This is done in a header section at the top of the file


 # Author: Your Name 
 # Description: Torch 
 # Category: Flashy 
 # License: MIT 
 # Appname : Torch 
 # Built-in: no 


You could save and run your app now, but it wont actually do anything yet. Lets add the code:


 # Author: Your Name 
 # Description: Torch 
 # Category: Flashy 
 # License: MIT 
 # Appname : Torch 
 # Built-in: no 
 
 import pyb
 pin = pyb.Pin(&amp;quot;LED_TORCH&amp;quot;)
 pin.high() 
 while True:
   pass

Save, and run your app. When you run it the LED should turn on, brill!

Of course, we're not showing anything on the screen. Lets have a nice notice box to show we're in the torch instead of that while loop.

 # Author: Your Name 
 # Description: Torch 
 # Category: Flashy 
 # License: MIT 
 # Appname : Torch 
 # Built-in: no 
 
 import pyb
 import ugfx
 import dialogs
 
 pin = pyb.Pin("LED_TORCH")
 pin.high() 
 ugfx.init()
 ugfx.clear(ugfx.html_color(0x7c1143))
 dialogs.notice("Shine a light!", title="Torch", close_text="Exit")

Run your app again and you should have a nice button you can press to shine a light in the camp!

You can unplug the badge from your computer when the LED has finished flashing, but we recommend you eject the drive first.</text>
      <sha1>ewudnyvs150z6m5sm0ckdb3k55oq9qt</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/memory problems</title>
    <ns>0</ns>
    <id>34</id>
    <revision>
      <id>176</id>
      <timestamp>2016-08-06T14:50:14Z</timestamp>
      <contributor>
        <username>Marekventur</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "=Call for Help: Memory Issues=  Please help the badge team: https://github.com/emfcamp/Mk3-Firmware/issues/71"</comment>
      <origin>176</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="109" sha1="1byzfnibha4156dtuu8veraqv26w1hs" xml:space="preserve">=Call for Help: Memory Issues=

Please help the badge team: https://github.com/emfcamp/Mk3-Firmware/issues/71</text>
      <sha1>1byzfnibha4156dtuu8veraqv26w1hs</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/modtilda</title>
    <ns>0</ns>
    <id>59</id>
    <redirect title="TiLDA MK4/modtilda" />
    <revision>
      <id>308</id>
      <parentid>293</parentid>
      <timestamp>2018-08-29T11:04:10Z</timestamp>
      <contributor>
        <username>Davea</username>
        <id>30</id>
      </contributor>
      <comment>Redirected page to [[TiLDA MK4/modtilda]]</comment>
      <origin>308</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="32" sha1="ctiluxl36oyjpf5ok3sdqd2oqzkhx4w" xml:space="preserve">#REDIRECT [[TiLDA_MK4/modtilda]]</text>
      <sha1>ctiluxl36oyjpf5ok3sdqd2oqzkhx4w</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/NeoPixel</title>
    <ns>0</ns>
    <id>37</id>
    <revision>
      <id>242</id>
      <parentid>221</parentid>
      <timestamp>2016-08-24T19:32:24Z</timestamp>
      <contributor>
        <username>JasperWallace</username>
        <id>9</id>
      </contributor>
      <comment>add some urls to examples.</comment>
      <origin>242</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1370" sha1="3icltpcrn6x5flob1kzikohaywtau51" xml:space="preserve">One feature of the Mk3 is a single NeoPixel multi-colour LED adjacent to the red power/charge LED.

==Faulty manufacture==
Unfortunately, during the original manufacture of the badges the NeoPixel was mounted 180 degrees out of orientation.  As originally delivered it will not function, being mounted with the triangular notch facing the outer part of the badge and the chip part of the LED (the brown spot under the transparent plastic) facing the charge LED.  The correct position is with the triangular notch facing inward and the chip part facing the "D1" label of the silkscreen.

===Correcting the faulty mount===
The best solution should be to use soldering tweezers take the LED off, clean the pads, turn it, and put it on but this is a delicate operation that will probably destroy the LED.  The trick is to be quick, to use a fairly high temperature (350-370 degrees) and add some new solder to the pads to increase the heat transfer.

You can possibly use two soldering irons at the same time, one on each side of the LED. 

Avoid hot air at all costs, the badge is packed and you don't really want to risk blowing the charging LED away or even worse, damaging the LCD.

==Programming the LED==

See this: https://github.com/mayhem/tilda-mk3-led-demo/blob/master/main.py

Or NeoPixelTest in the App Library: http://api.badge.emfcamp.org/app/emuboy/neopixtest</text>
      <sha1>3icltpcrn6x5flob1kzikohaywtau51</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/reset</title>
    <ns>0</ns>
    <id>22</id>
    <revision>
      <id>253</id>
      <parentid>252</parentid>
      <timestamp>2017-01-16T11:11:19Z</timestamp>
      <contributor>
        <username>Jonty</username>
        <id>45</id>
      </contributor>
      <origin>253</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1187" sha1="mko3lo9qnjsly04jnftaztmr2yg4mkp" xml:space="preserve">Should your badge stop working there are three ways to fix it. Please make sure you have a backup of whatever you've been working on, you might lose all the data stored on your badge.

It's best to try these in sequence, however if you just want to factory reset your badge skip to option (3).

# Try deleting the file you have been working on, "safely eject" the badge and then press the reset button.
# Delete all other files apart from &lt;code&gt;boot.py&lt;/code&gt;, &lt;code&gt;wifi.json&lt;/code&gt; and &lt;code&gt;bootstrap.py&lt;/code&gt;, "safely eject" the badge and then press the reset button.
# Factory reset the badge. Press and hold 'MENU' and then press the reset button on the back. Keep the MENU button held down, then release it when both the green light is on and the screen is white.

All these steps should finally get you to a screen saying "Downloading TiLDA software". It should take less than a minute until the bare badge functionalities are restored.

P.S. The micropython documentation on factory resetting is [http://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/reset.html here]. On the TiLDA MK3 the USR button is the MENU button, and the orange light is the screen going white.</text>
      <sha1>mko3lo9qnjsly04jnftaztmr2yg4mkp</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/rtc</title>
    <ns>0</ns>
    <id>16</id>
    <revision>
      <id>256</id>
      <parentid>43</parentid>
      <timestamp>2017-03-02T00:52:07Z</timestamp>
      <contributor>
        <username>Claude</username>
        <id>47</id>
      </contributor>
      <comment>fix broken link to micropython rtc docs</comment>
      <origin>256</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="360" sha1="io0z3k23ppay8ise9gp1qkt0h7w9fvf" xml:space="preserve">The following code snippets demonstrate the RTC. See the micropython docs [https://docs.micropython.org/en/latest/pyboard/library/pyb.RTC.html] for more information.

&lt;pre&gt;
# Create a RTC object
rtc = pyb.RTC()

# If the RTC isn't running, call
rtc.init()

# Set the time 
rtc.datetime((2016, 5, 1, 4, 13, 0, 0, 0))

# Get the time
print(rtc.datetime())
&lt;/pre&gt;</text>
      <sha1>io0z3k23ppay8ise9gp1qkt0h7w9fvf</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/Run Code</title>
    <ns>0</ns>
    <id>28</id>
    <revision>
      <id>260</id>
      <parentid>238</parentid>
      <timestamp>2017-03-02T01:22:43Z</timestamp>
      <contributor>
        <username>Claude</username>
        <id>47</id>
      </contributor>
      <comment>/* Option 1: REPL */ fix broken link to micropython repl tutorial</comment>
      <origin>260</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2668" sha1="pu2f8k7omvymvgqjr2n3ep139dbwc80" xml:space="preserve">This video is meant for the micropython board, but most of it works similar on the TiLDA: https://micropython.org/ 

= Option 1: REPL =
REPL stands for "[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop Read‚Äìeval‚Äìprint loop]" and allows you to run python code, line by line. This is a great way to see effects of certain hardware commands instantly and to test basic python features. 

This allows you to run code, line by line, on the badge and to see the effects instantly. Follow https://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/repl.html or follow step 1-4 on the [[TiLDA_MK3/Get_Started|Get Started]] guide. 

&lt;strong&gt;Note:&lt;/strong&gt; This will only work if you have an empty &lt;code&gt;main.py&lt;/code&gt; on your badge to stop the home screen from taking over instantly. If an app or script is already running you will not get a REPL that you can use to program, but simple debug output instead. Remember to remove it afterwards if you want to use the home screen again.

You can also press Ctrl-C to stop the currently running app and get to the python prompt.

= Option 2: Copying files =
You can also copy your code to &lt;code&gt;main.py&lt;/code&gt; on your badge, safely eject and then reset the badge via the button. To debug it you can use the serial console (see option 1) which will show you all text printed via &lt;code&gt;print()&lt;/code&gt; and errors.

&lt;strong&gt;Note:&lt;/strong&gt; It's very important to always correctly "eject" the usb storage before pressing the reset button, otherwise your filesystem is going to corrupt and you might have to [[TiLDA_MK3/reset|factory reset]] your badge

Remember to remove your main.py afterwards if you want to use the home screen again.

On Linux you can use this script to automatically mount the TILDA -&gt; sync files from a local directory -&gt; safely eject: https://gist.github.com/IVBakker/fbab508c336397323d6c1caef8cdc46c

= Option 3: pyboard.py =
You can also use micropythons's &lt;code&gt;pyboard.py&lt;/code&gt; script to automatically run a full local file of code without having to worry about copying it line-by-line or ejecting your device. 
 
You can find a quick introduction on how to set it up [https://badge.emfcamp.org/wiki/TiLDA_MK3/Get_Started#5._Run_a_whole_file_of_code here].

This option is very useful as a build script with your editor, it allows you to quickly test whether your app is working. 

&lt;strong&gt;Note:&lt;/strong&gt; While this option works even if you run the home screen, it works slightly better if you have an empty &lt;code&gt;main.py&lt;/code&gt; on your badge.

=== Sublime Text 2 build script ===
OSX:
&lt;pre&gt;
{
    "shell_cmd": "/path/to/your/pyboard.py --device /dev/tty.usbmodem* $file"
}
&lt;/pre&gt;</text>
      <sha1>pu2f8k7omvymvgqjr2n3ep139dbwc80</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/spi</title>
    <ns>0</ns>
    <id>56</id>
    <revision>
      <id>283</id>
      <parentid>282</parentid>
      <timestamp>2018-07-07T22:48:49Z</timestamp>
      <contributor>
        <username>Chrisstubbs</username>
        <id>49</id>
      </contributor>
      <origin>283</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="498" sha1="gpr7rluh1mbdh168ixprfcu0b8n7o5v" xml:space="preserve">See here [https://docs.micropython.org/en/latest/pyboard/library/pyb.SPI.html] for the main micropython documentation.

SPI1 is used for the board's onboard wifi.

SPI2 is exposed on the 'X' header, under the white silkscreen section for your name.


&lt;pre&gt;
from pyb import SPI

spi = SPI(2) #create SPI on port 2
spi.init(SPI.MASTER) #set the mode. Other things like baudrate=80000, polarity=1, phase=0, crc=None can be set here

spi.send(170) #send int byte
spi.send(b'\xAA') #send hex byte
&lt;/pre&gt;</text>
      <sha1>gpr7rluh1mbdh168ixprfcu0b8n7o5v</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/subtree</title>
    <ns>0</ns>
    <id>15</id>
    <revision>
      <id>41</id>
      <timestamp>2016-07-07T17:33:19Z</timestamp>
      <contributor>
        <username>Marekventur</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "= UGFX subtree management = The folder UGFX is a subtree tracking git@bitbucket.org:mattbrejza/ugfx.git. Please don't edit anything in there directly unless you know what you'..."</comment>
      <origin>41</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="633" sha1="h4rl52817cxtp8lw75ifjhamp9jyyc1" xml:space="preserve">= UGFX subtree management =
The folder UGFX is a subtree tracking git@bitbucket.org:mattbrejza/ugfx.git. Please don't edit anything in there directly unless you know what you're doing.

Read https://medium.com/@porteneuve/mastering-git-subtrees-943d29a798ec for more information on the topic.

== Prerequisites==
&lt;pre&gt;
git remote add ugfx git@bitbucket.org:mattbrejza/ugfx.git
&lt;/pre&gt;

== How it's set up==
&lt;pre&gt;
git read-tree --prefix=extmod/ugfx -u ugfx/master
git commit -m "..."
&lt;/pre&gt;

== How to update the subtree==
&lt;pre&gt;
git fetch ugfx
git merge -s subtree --squash ugfx/master
git commit -m "Update UGFX subtree to ..."
&lt;/pre&gt;</text>
      <sha1>h4rl52817cxtp8lw75ifjhamp9jyyc1</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/timer</title>
    <ns>0</ns>
    <id>20</id>
    <revision>
      <id>278</id>
      <parentid>257</parentid>
      <timestamp>2018-07-06T22:23:59Z</timestamp>
      <contributor>
        <username>Chrisstubbs</username>
        <id>49</id>
      </contributor>
      <origin>278</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1060" sha1="gh11fwf3ibjja8jfrffoppuy4xst8n5" xml:space="preserve">See the micropython documentation [https://docs.micropython.org/en/latest/pyboard/library/pyb.Timer.html] for a detailed explanation. Some examples are below.

Note that when your program completes executing, the badge will restart back to the main menu. If your program doesn't do anything else after initialising the timer, the badge will look like it just restarts when you run your program! If you just want the timer callback to keep running and do nothing else, end your program with a loop like "while True: pass".

== Function callbacks ==

&lt;pre&gt;
flag = 0

#note, this callback needs to take one parameter, which is what timer is calling it
def tim_callback(t):
    global flag
    flag = 1

timer = pyb.Timer(3)
timer.init(freq=1)
timer.callback(tim_callback)

....

timer.deinit()
&lt;/pre&gt;

or, using lambdas

&lt;pre&gt;
flag = 0

#the use of lambda avoids needing the function to take an argument
def tim_callback():
    global flag
    flag = 1

timer = pyb.Timer(3)
timer.init(freq=1)
timer.callback(lambda t: tim_callback())

....

timer.deinit()
&lt;/pre&gt;</text>
      <sha1>gh11fwf3ibjja8jfrffoppuy4xst8n5</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/ugfx</title>
    <ns>0</ns>
    <id>13</id>
    <revision>
      <id>286</id>
      <parentid>241</parentid>
      <timestamp>2018-08-12T17:47:23Z</timestamp>
      <contributor>
        <username>Binney</username>
        <id>50</id>
      </contributor>
      <comment>wrong function name in example, maybe was copypasta originally?</comment>
      <origin>286</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="14648" sha1="q5en5v2yoa6pl9dess0vxwtoowgrly7" xml:space="preserve">The badge makes use of [http://ugfx.io uGFX] for providing drawing functions on the LCD. Most of this functionality is available through the micropython interface, and you may wish to browse the [https://wiki.ugfx.io/index.php/Main_Page  uGFX documentation] for more details.

To discover exactly which ugfx calls are available in micropython, see https://github.com/emfcamp/micropython/blob/tilda-master/stmhal/modugfx.c

== Basic usage ==

uGFX is comprised of 'widgets,' such as buttons and labels, and 'containers' which are used to group widgets.

To create a button on the screen, use &lt;code&gt;ugfx.Button(x,y,width,height,text)&lt;/code&gt;, and a button will be drawn on the screen.

As well as widgets, there are 'primitives' such as drawing circles and lines, which can be drawn anywhere on the screen or in a container.
For example &lt;code&gt;ugfx.circle(50,50,20,ugfx.RED)&lt;/code&gt; will draw a circle.



== Detailed documentation ==

Note. all co-ordinates are from the top left (battery symbol) corner. All widgets are created from the "ugfx" package, eg: ugfx.Contailer().

=== Colour format ===

Internally, ugfx uses 565 format (5 bits for red and blue, 6 for green). Preset colours are available, for example '''ugfx.RED''', '''ugfx.ORANGE''', etc. To convert from 24 bit RGB format, use '''ugfx.html_color(0xRRGGBB)''' to return the 16 bit 565 format.

=== Styles and Fonts ===
Use &lt;code&gt;ugfx.set_default_font(...)&lt;/code&gt; to change the font. The font options are:
* ''ugfx.FONT_SMALL''
* ''ugfx.FONT_MEDIUM''
* ''ugfx.FONT_MEDIUM_BOLD''
* ''ugfx.FONT_TITLE''
* ''ugfx.FONT_NAME''.
Note that widgets use the font which was default when they were created, while the ''container.text()'' primitive uses the font that was default when the container was created

=== Containers ===

    .Container(x, y, width, height {,style})  # the style is optional

Containers can be used to group widgets together. They can also perform primitive drawing functions. When drawing widgets or primitives, the coordinates are relative to the top left corner of the container.

Containers can be shown or hidden, and all the widgets will be redrawn. Containers can also be placed on top of other widgets. When the top container is hidden, the widgets below will be redrawn.

Upon creation a style can be passed to a container, which will then be used by default by widgets created as part of that container. If no style is specified at creation, the current default style will be used.

The following example shows  how to create a container, add an object and show it.
&lt;pre&gt;
c = ugfx.Container(100,100,200,100)
b = ugfx.Button(10, 10, 40, 30, "OK", c)
c.show()            # the container will not be shown until this point
&lt;/pre&gt;

=== Primitives ===
All primitives can be drawn anywhere on the screen with, for example &lt;code&gt;ugfx.circle(..)&lt;/code&gt;, or anywhere within a container, with &lt;code&gt;c=ugfx.Container(30,30,100,100); c.circle(..)&lt;/code&gt;

==== Clear ====

&lt;code&gt;.clear(colour = ugfx.WHITE)&lt;/code&gt;

clears the screen to the specified colour. Warning, this is slow!

==== Lines ====
&lt;code&gt;.line(&lt;x1&gt;, &lt;y1&gt;, &lt;x2&gt;, &lt;y2&gt;, &lt;colour&gt;)&lt;/code&gt;

&lt;code&gt;.thickline(&lt;x1&gt;, &lt;y1&gt;, &lt;x2&gt;, &lt;y2&gt;, &lt;colour&gt;, &lt;width&gt;, &lt;round&gt;)&lt;/code&gt;

Draws a line from ''x1,y1'' to ''x2,y2'' using ''colour''. Thickline will draw a line or arbitrary width, with the option of rounded corners

eg. ''ugfx.thickline(0,0,100,170,ugfx.YELLOW,7,0)''

==== Circle ====
&lt;code&gt;.circle(x, y, diameter, colour)&lt;/code&gt;

&lt;code&gt;.fill_circle(x, y, diameter, colour)&lt;/code&gt;

Draws a circle at ''x,y'' of &lt;diameter&gt; using ''colour'', either with a 1 pixel border or filling the area.

eg. ''ugfx.circle(180,150,40,ugfx.RED)''

==== Arc ====
&lt;code&gt;.arc(x, y, r, angle1, angle2, colour)&lt;/code&gt;

&lt;code&gt;.fill_arc(x, y, r, angle1, angle2, colour)&lt;/code&gt;

Similar to the circle functions, however two angle parameters specify between which two angles drawing occurs

==== Ellipse ====
&lt;code&gt;.ellipse(x, y, a, b, colour)&lt;/code&gt;

&lt;code&gt;.fill_ellipse(x, y, a, b, colour)&lt;/code&gt;

Draws an ellipse at ''x,y'' of ''a'' width and ''b'' height using ''colour'', either with a 1 pixel border or filling the area.

==== Rectangles ====
&lt;code&gt; .box(1, y, a, b, colour) &lt;/code&gt;

&lt;code&gt; .area(x, y, a, b, colour)&lt;/code&gt;

Draws a rectangle or filled rectangle at ''x,y'' of ''a'' width and ''b'' height using ''colour''.

==== Polygon ====
&lt;code&gt; .polygon(x, y, array, colour) &lt;/code&gt;

&lt;code&gt; .fill_polygon(x, y, array, colour) &lt;/code&gt;

Draws or fills a polygon starting at ''x,y'' using ''colour''. ''Array'' is an array of coordinates that specifies the corners.

eg. ''ugfx.polygon(0,0, [ [0,20],[20,20],[20,0]], ugfx.RED)''

==== Text ====
&lt;code&gt;.text(x, y, text, colour) &lt;/code&gt;

Draws a text string ''text'' at ''x,y'' in ''colour''.
Note that a ugfx.text(..) call will take the default font, while container.text(..) will take the containers font.

eg. ''ugfx.text(40,40,"My name is...",ugfx.BLUE)''

==== Other ====
&lt;code&gt;.width()&lt;/code&gt;

&lt;code&gt;.height()&lt;/code&gt;

Gets the height or width of the screen ''ugfx.width()'' or container object ''c.width()''

=== Widgets ===

Widgets can be drawn anywhere on the screen, or within a container. The widgets take the optional parameter ''parent='' to set the parent container. Widgets can have their style set on creation, otherwise will inherit 

Widgets also accept input from the buttons. For example, the 'A' button can be 'attached' to an on-screen button, such that pressing the button on the badge causes the on-screen button to be redrawn in a depressed state. 

==== Common Widget methods ====

&lt;code&gt;.text([text])&lt;/code&gt;

Gets or sets the text displayed by the widget.

&lt;code&gt;.visible([show])&lt;/code&gt;

Gets or sets the visibility of the badge. ''b.visible(0)'' will hide, and ''b.visible(1)'' will show.

&lt;code&gt;.attach_input(button, function)&lt;/code&gt;

Attaches a physical button to a widget, so that the user can cause the widget to redraw, for example to scroll or become depressed.

The input ''button'' specifies which button, with the options ugfx.BTN_A, ugfx.BTN_B, ugfx.BTN_MENU, ugfx.JOY_UP, ugfx.JOY_DOWN, ugfx.JOY_LEFT, ugfx.JOY_RIGHT.

The input ''function'' specifies what the button actually does. For example, the list has three different functions: scroll up, scroll down, and select. Note that some widgets by default attach the joystick to the relevant functions. 

&lt;code&gt;.detach_input(function)&lt;/code&gt;

Detaches an input. See above for more details.

&lt;code&gt;.destroy()&lt;/code&gt;

Frees up all the resources assoicated with the object. While the micropython garbage collector will clear any old objects, the graphics library also has its own memory area, which can become full if objects are not destroyed after they are needed.

&lt;code&gt;.set_focus()&lt;/code&gt;

Gives focus to the widget instance. Normally this will draw a box around the widget, the colour is specified by the style.

==== Button ==== 

&lt;code&gt; b=ugfx.Button(x, y, w, h, text, *, parent=None, trigger=None, shape=ugfx.Button.RECT, style=None) &lt;/code&gt; (note: parameters after '*' are optional)

Draws a button at ''x,y'' having width ''a'' and height ''b''. The option 'trigger' specifics which physical switch (if any) causes the display to be redrawn. The shape options are ''ugfx.Button.RECT'', ''ugfx.Button.ROUNDED'', ''ugfx.Button.ELLIPSE'', ''ugfx.Button.ARROW_UP'', ''ugfx.Button.ARROW_DOWN'', ''ugfx.Button.ARROW_LEFT', ''ugfx.Button.ARROW_RIGHT''.

==== Textbox ====
&lt;code&gt; ugfx.Textbox(x, y, w, h, *, text=None, parent=None, maxlen=255})&lt;/code&gt;

Draws a text edit-box which can take input from the on-screen keyboard. Will automatically accept key-presses from the keyboard, which will edit the text. The textbox needs to have focus using .set_focus() for it to receive the key-presses.

==== Checkbox ====

&lt;code&gt;.Checkbox((x, y, w, h, text=None, parent=None, trigger=None, style=None)&lt;/code&gt;

&lt;code&gt;.checked()&lt;/code&gt;

Get or set the checked state


==== Label ====

&lt;code&gt; ugfx.Label(x, y, w, h, text, *, parent=None, style=None, justification=None)&lt;/code&gt;

A label displays text. Unlike the primitive text, this Label supports different justifications, wordwrap and changing text. The different justification options are ''ugfx.Label.LEFT'', ''ugfx.Label.RIGHT'', ''ugfx.Label.CENTER'', ''ugfx.Label.LEFTTOP'', ''ugfx.Label.RIGHTTOP'' and ''ugfx.Label.CENTERTOP''.

==== List ====

&lt;code&gt;ugfx.List(x, y, w, h, *, parent=None, up=ugfx.JOY_UP, down=ugfx.JOY_DOWN, style=None)&lt;/code&gt;

&lt;code&gt;.enable_draw()&lt;/code&gt;

&lt;code&gt;.disable_draw()&lt;/code&gt;

&lt;code&gt;.add_item(text)&lt;/code&gt;

&lt;code&gt;.assign_image(index, image)&lt;/code&gt;

&lt;code&gt;.remove_item(index)&lt;/code&gt;

&lt;code&gt;.selected_text()&lt;/code&gt;

&lt;code&gt;.selected_index()&lt;/code&gt;

&lt;code&gt;.count()&lt;/code&gt;

==== Graph ====

&lt;code&gt;ugfx.Graph(x, y, w, h, origin_x, origin_y)&lt;/code&gt;

&lt;code&gt;.show()&lt;/code&gt;

&lt;code&gt;.hide()&lt;/code&gt;

&lt;code&gt;.set_arrows(ugfx.Graph.ARROWS_X_POS | ugfx.Graph.ARROWS_Y_POS)&lt;/code&gt;

Set which axes have arrows and in which direction. In this example arrows are set for the x and y positive directions, with the following options available: ARROWS_X_POS, ARROWS_Y_POS, ARROWS_X_NEG, ARROWS_Y_NEG


&lt;code&gt;.plot( point(s)_x, point(s)_y, {new_series} )&lt;/code&gt;

Plot either an array, or a point. Optional second parameter specifies whether to start a new series or join onto previous.


&lt;code&gt;.appearance( thing_to_change, shape, size, colour, {spacing}  )&lt;/code&gt;

Changes the style of either points, lines, axis or grids. Each parameter is used as follows:

'thing_to_change' - select what aspect to change, the options are {STYLE_POINT, STYLE_LINE, STYLE_XAXIS, STYLE_YAXIS, STYLE_XGRID, STYLE_YGRID}

'shape' - selects the shape of the thing to change, where the options depend on what you are changing.
The options for points is: {POINT_NONE, POINT_DOT, POINT_SQUARE, POINT_CIRCLE}
The options for line/axis/grid are: {LINE_NONE, LINE_SOLID, LINE_DOT, LINE_DASH}

'size' - number of pixels wide of the thing to change

'colour' - use UGFX.Red, UGFX.Orange,...  or UGFX.html_color(0xRRGGBB) to ensure the right format

'spacing' - only valid for grid

See the [https://github.com/emfcamp/Mk3-Firmware/blob/master/apps/logger/main.py BARMS logger app] for an example

==== ImageBox ====

&lt;code&gt;.ImageBox(x, y, w, h, filename, *, cache=0, parent=None, style=None)&lt;/code&gt;

==== Keyboard ====

&lt;code&gt;.Keyboard(x, y, w, h, parent=None)&lt;/code&gt;

=== Styles ===
&lt;pre&gt;
s=ugfx.Style()  # create a style based on the current default style

s.set_enabled([text_colour, edge_colour, fill_colour, progress_colour]) # sets the style for when something is enabled
s.set_pressed([text_colour, edge_colour, fill_colour, progress_colour]) # sets the style for when something is pressed
s.set_disabled([text_colour, edge_colour, fill_colour, progress_colour]) # sets the style for when something is disabled

s.set_focus(colour)  # sets the colour used for focus
s.set_background(colour) # sets the background colour for the style

ugfx.set_default_style(s) # use this style from now on

b=ugfx.Button(0,0,40,30,"OK", style=s) # use the style for this button

&lt;/pre&gt;

== Tips and tricks ==

=== Tearing ===

When writing large areas of the screen, a 'tearing' [https://en.wikipedia.org/wiki/Screen_tearing] effect may be observed.

The screen module is comprised of a large memory, with one memory location to store the RGB data for each pixel. The LCD driver continuously updates the LCD pixels, by reading the memory in a sequential, line-by-line manner, and updating the LCD with the data from the memory. This 'read line-pointer' moves from the top to the bottom of the screen (when viewed in portrait), at about 70Hz (the refresh rate of the screen)

This large memory as part of the screen means it can be driven by a microcontroller which may have a considerably smaller memory. The microcontroller therefore only needs to update the memory when it whats the content to change. 

Consider the scenario where the microcontroller wants to set the screen from one colour to another. The microcontroller needs to update the entire memory (320x240x2 = 153kB) with the new colour. At the same time the 'read line-pointer' is reading the same memory to update the LCD. In this case, tearing occurs if the 'read line-pointer' reads the top half of the memory containing the new colour, but then catches up with microcontroller writing to the memory, then the 'read line-pointer' starts reading the old colour in the bottom half of the memory.

To avoid tearing the 'read line-pointer' should not cross the region the microcontroller is updating. Since the microcontroller writes to the screen slightly slower than the LCD reads it, providing the microntroller starts writes to the top of the memory just after the LCD starts reading from the top, the read and write pointers will not overlap, and tearing will not occur. To sync the microcontroller with the LCD 'read line-pointer,' there is a vsync/tear output (connected to pin named 'TEAR') which is pulled high when the 'read line-pointer' reaches a given line (default is line 0). This can be turned on and off with '''ugfx.enable_tear()''' and '''ugfx.disable_tear()'''. To change the line at which the tear output is generated, use '''ugfx.set_tear_line(0..319)'''.

Example code:

    ugfx.enable_tear()
    tear = pyb.Pin("TEAR", pyb.Pin.IN)
    
    def vsync():
        while tear.value() == 0:
            pass
        while tear.value():
            pass

=== Reducing power consumption ===
Use the following to dim the backlight, which uses about 80mA at full brightness
&lt;pre&gt;
ugfx.backlight(b)     # sets the backlight. Range is 0-100
b = ugfx.backlight()   # reads the current backlight
&lt;/pre&gt;

== Top-Level calls ==

&lt;code&gt;.power_mode(&lt;mode&gt;)&lt;/code&gt;

''mode'' can be any of: ugfx.POWER_ON, ugfx.POWER_OFF, ugfx.POWER_DEEP_SLEEP, ugfx.POWER_SLEEP

&lt;code&gt;.orientation(deg)&lt;/code&gt;

Rotate the display by number of degrees, eg 180 for upside-down.

Calling with no args returns the current value

&lt;code&gt;.display_image(x, y, '/path/to/image', orientation)&lt;/code&gt;
&lt;code&gt;.display_image(x, y, img_obj, orientation)&lt;/code&gt;

Display an image from a file of a supported type, or a previously opened image object, on screen at the x,y co-ordinates. Optionally change its orientation.

&lt;code&gt;.write_command(0x35,0)&lt;/code&gt;

Low-level command to write to a data register directly.

&lt;code&gt;.poll()&lt;/code&gt;

Yield to ensure the screen is redrawn when waiting on user input

&lt;code&gt;.ball_demo()&lt;/code&gt;

Ball Demo!

&lt;code&gt;.get_pixel(x, y)&lt;/code&gt;

Returns the colour of the pixel at x,y

&lt;code&gt;.Image(filename, cacheme)&lt;/code&gt;

Creates and returns (or loads from cache) a ugfx image object from the image in the filename.</text>
      <sha1>q5en5v2yoa6pl9dess0vxwtoowgrly7</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK3/wifi</title>
    <ns>0</ns>
    <id>19</id>
    <revision>
      <id>148</id>
      <parentid>118</parentid>
      <timestamp>2016-08-06T07:42:15Z</timestamp>
      <contributor>
        <username>Marekventur</username>
        <id>10</id>
      </contributor>
      <comment>/* wifi.json */</comment>
      <origin>148</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="506" sha1="759sm5assqkgokc6ao4wxnlmlf5fg0w" xml:space="preserve">= wifi.json =
A simple json document in the root directory of the badge:
&lt;pre&gt;
{"ssid":"your-wifi-name","pw":"your-wifi-password"}
&lt;/pre&gt;

If you're connecting to an open wifi you can leave out the "pw" :
&lt;pre&gt;
{"ssid":"your-unsecured-wifi-name"}
&lt;/pre&gt;

Most badge apps that use the wifi chip will expect a wifi.json file to exist. Please make sure it's valid json and that both name and password are in the correct case. 

Please make sure to "eject" the usb storage properly before restarting the badge.</text>
      <sha1>759sm5assqkgokc6ao4wxnlmlf5fg0w</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4</title>
    <ns>0</ns>
    <id>57</id>
    <revision>
      <id>482</id>
      <parentid>467</parentid>
      <timestamp>2024-03-28T09:55:40Z</timestamp>
      <contributor>
        <username>Raj</username>
        <id>23</id>
      </contributor>
      <origin>482</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="13268" sha1="mj3875vfbnv7i97ucm1mop71jwg9onx" xml:space="preserve">[[File:TiLDA_Mk4_Front_with_sponsors.png|right|500px|TiLDA Mkùõø]]

== Using your badge ==

&lt;div style="background-color: #FFFFDD; border: 1px solid #808000; padding: 5px;"&gt;&lt;strong&gt;If you just got your badge and it doesn't do anything&lt;/strong&gt;, don't despair, quite a few of them need to be [[TiLDA_MK4/reset|factory reset]] before showing the loading screen. Press and hold &lt;code&gt;MENU&lt;/code&gt; while quickly pressing the reset button at the back. Keep the &lt;code&gt;MENU&lt;/code&gt; button hold for another 2 seconds. Release it when both the red and green LED are lit. If you got it correct both LEDs should flash a few times.&lt;br&gt;If this doesn't work you can [[TiLDA_MK4/Firmware_Update|update the badge firmware]]. If this doesn't work, please come and join us in #emfcamp-badge on [https://libera.chat/ Libera IRC]&lt;/div&gt;

=== Updating your badge firmware ===
After (and during!) EMF the badge firmware was substantially fixed and improved, resolving issues with call handling and apps.

Please update your badge firmware as soon as possible. You can find [[TiLDA_MK4/Firmware_Update|documentation on this here]].

=== Assembly ===
With your badge you will receive a booklet explaining how it's done. If you have any problems, please come to the Badge Operation Center and we will help you.&lt;br&gt;
Booklet can be found [https://archive.org/details/emf2018_badge_guide here]

=== Basic usage ===
After you have assembled your badge you can just use the tiny switch at the bottom of the screen to turn your badge on. Alternatively you can use any USB power source. If you turn your badge on for the first time (or if for some reason it has reset itself) you will get some on-screen information while we try to download the newest set of software. '''This doesn't always work on the first try, you might have to use "reset" to try a few times'''

If at any point you want to restart your badge you can just press the reset button on the back below the display ribbon. 

==== Changing your name ====

# Press 'Menu'
# Select the 'Settings" app
# "Change Name" and press 'A'
# Use the joystick and 'A' key to enter your name
# Press 'Menu' to save your name and reset the badge - your name should now be displayed!

==== Installing new apps ====

# Press 'Menu'
# Select 'Badge Store' app and press 'A'
# Select "Install"
# Select a category and then an app. Wait until you see the description and press "A" to save it.
# Press B a few times (or alternatively MENU) to restart your badge
# On the home screen you can now press MENU to find your newly installed app.

=== WiFi ===
Your TiLDA Badge has built-in wifi support. It should all just work if you're at the campsite, but if you're on your own network you might have to tell the badge about it. For more information please have a look here: [[TiLDA MK4/wifi|WiFi]]

=== Charging ===
The badge charges via a microUSB socket, and takes about 2-3 hours for a full charge. The red charge LED to the right of the display ribbon on the back will extinguish when charging is complete.

=== Calling and SMS ===

'''Warning: The badge team are aware of an issue of instability while using the calling capability. Please bear with us while we diagnose this.'''

Yes your TiLDA Badge is also a mobile phone. To connect to the EMF mobile network insert the Hologram SIM supplied, load the "phone" app, select "Select Operator", wait, wait some more, and a little longer, then select "EMF" or "23404". Select "Auto" to use a public mobile network again.

To find out your number on the EMF network select "Information" in the phone app. If "Operator" is not shown on the information screen then you have failed to connect to the network. If you are not given a number then wait a little longer and try again. You can read and send SMS messages with the "sms" app. You can also answer calls by pressing "Call" in any app, and end or reject a call using the "End" button at any time.

&lt;Radiocode&gt; The cellular part of the badge seems to work (reliably) perfectly if an external antenna is used, such as a mag-mount with a length of coax. Seems to be an EMC issue, as using the pictured right angle antenna directly on the SMA does not work reliably.  Time to get the Kapton tape and copper foil out...

[[File:GSM Antenna.jpg]]

=== Connecting over USB ===
By default, the software is in a loop. If you want to interact over the REPL you need to exit this. The easiest way is to press Ctrl-C.

It's hard to press Ctrl-C in minicom, so on Linux this is easier to do with screen:
&lt;pre&gt;
screen /dev/ttyACM0 115200
&lt;/pre&gt;

If you can connect but Ctrl-C has no effect then it is possible that another service on your machine is accessing the tty before you can connect. A likely candidate is modemmanager. You can check if ModemManager is running using:

&lt;pre&gt;
systemctl | grep -i modem
&lt;/pre&gt;

and can be stopped with:

&lt;pre&gt;
systemctl stop ModemManager.service
&lt;/pre&gt;

On Mac:
&lt;pre&gt;
screen /dev/tty.usbmodemTiLDA2
&lt;/pre&gt;

To exit screen, press Ctrl-A, then k, then y.

On Windows:
# If you don't have PuTTY or a similar program, get PuTTY installer from [https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html]
# Open PuTTY and select Serial connection
# Change COM1 to the COM port for your badge (You can usually find this as USB Seiral Port under ports in device manager)
&lt;font color="#606060"&gt;&lt;i&gt;Note: if your badge resets while putty is open, you will have to close the window and open a new connection to the same COM port.&lt;/i&gt;&lt;/font&gt;

The basic process is this:

# Connect device to computer with usb
# Fire up minicom or screen
# Press reset button on device
# Hit Ctrl+C quickly and with vigour to get to the REPL before the UI comes up

=== Nothing works! Help! ===

Don't worry, you can always "factory reset" your badge. Please follow these instructions: [[TiLDA_MK4/reset|Resetting]]

If everything else absolutely fails, you can try following these instructions (advanced): [[TiLDA_MK4/Firmware_Update]]

== Hacking your badge ==

=== App Hack ===

'''[https://gist.github.com/SteveAmor/8c333927fded2339da54ad4aaa765d7e A method to hack your app onto your badge]'''

=== Tilda Tools ===


'''[[TiLDA_MK4/tilda-tools|tilda-tools]]''' - Should now work on Windows, Linux and OSX

=== OSX ===

Mass storage now works on OSX


'''[[TiLDA_MK4/Introduction_to_badge_hacking|Badge Hacking Workshop Documentation]]'''


One of the main goals of TiLDA is to make hacking it as easy as possible. All you need to do so is a computer with USB and your badge.

* '''[[TiLDA_MK4/tilda-tools|tilda-tools]]''' - the one-stop interface for all your badge needs
* '''[[TiLDA MK4/Get Started|Step-by-step]]''' - to make it as easy as possible to get going
* '''[[TiLDA MK4/Run Code|3 Ways to run code on your TiLDA]]'''
* '''[[TiLDA MK4/Badge Store Submissions|Badge Store Submissions]]''' - Share your creations with others
* '''[[TiLDA MK4/Code Structure|Code Structure]]''' - How the python code is structured

The badge itself runs code written in the computer language [https://en.wikipedia.org/wiki/Python_(programming_language) Python] which is run by a bit of software called [https://micropython.org/ Micropython]. 

For more information about the functions available please have a look at the [[#Badge API|Badge API]] section of this page.

In case you're more interested in what makes the hardware tick and your confident with C++ and microprocessors then you can work directly with the micropython code that runs TiLDA: [[TiLDA MK4/build|How to build the firmware from scratch]]

All code used is hosted on Github. Contributions and PR are very welcome!
* https://github.com/emfcamp/Mk4-Apps
* https://github.com/emfcamp/Mk4-Backend (powers the badge store)
* https://github.com/emfcamp/Mk4-micropython-board

=== Building Micropython Firmware ===
[[TiLDA_MK4/BuildingFirmware|Build Instructions]]

=== Some ideas ===

[[TiLDA MK4/Ideas|Please share what you've done (or want to do) with others!]]

Tips by Ben Woodley (Tested on Ubuntu 18.04 and Debian Stretch)

'''If you're having issues with getting the python prompt while using a serial terminal or the tilda_tools is failing'''
Error displayed: SerialTimeoutException: Write Timeout
Fix: 
* Do this command (ModemManager steals your escape characters!)
* $ sudo systemctl stop ModemManager.service
* Then make sure your badge is in an app (anything but the purple home screen)
* Try open a serial terminal with the device (e.g. screen /dev/ttyACM0 115200)
* The issue should not persist

'''Reflash the firmware'''
* If lets say you wanted to '''force a firmware update to apply the patch for making phone calls''' then just follow these steps.
* $ git clone https://github.com/micropython/micropython.git
* $ cd micropython/ports
* $ git clone https://github.com/emfcamp/Mk4-micropython-board.git
* $ cd Mk4-micropython-board
* $ ./inst_tools
* $ make
* You may need additional packages depending on your distro, follow the errors if encountered with inst_tools or make.
* Put the badge in DFU mode (press and hold the centre button of the joystick and press reset button, let go of joystick after a second)
* $ make flash-dfu
* This will reflash the firmware, if it fails your board is either not in dfu mode or you need additional packages (like python3-serial in apt!)

'''Using the Grove Serial connector'''

&lt;Radiocode&gt;
The Badge Team thoughtfully chose to include a couple of Seeed Studio Grove system connectors to the 2018 badge. Looking at the rear of the badge, 
they are either side of the unpopulated 3.5mm jack footprint, top right. 
*On the left is the Grove I2C connector &lt;anyone using this?&gt;
*On the right is the Grove UART connector
The Grove UART is helpfully labelled "UART4". To use it in Python, it is actually number 2!!!

Example: 

import machine

u = machine.UART(2, 9600) 

g = u.readline()

etc...

can be used to communicate with the Seeed Studio GPS module. [Seeed Studio: http://wiki.seeedstudio.com/Grove-GPS/]

== Badge API ==

=== Build-in ===
* [http://docs.micropython.org/en/latest/pyboard/ documentation] - General Micropython libarary
* [[TiLDA MK4/ugfx|uGFX]] - The TiLDA LCD colour screen
* [[TiLDA MK4/documentation/cc3100|CC3100]] - The wifi chip
* [[TiLDA MK4/rtc|RTC]] (real time clock)
* [[TiLDA MK4/sensors|Sensors]]
* [[TiLDA MK4/sim800|SIM800]] (GSM/Phone/Bluetooth)
* [[TiLDA MK4/modtilda|import tilda]] (our custom micropython module)
* [[TiLDA MK4/spi|SPI]] SPI
* [[TiLDA MK4/Neopix|Neopix]] WS2812B LEDs
* please add

=== TiLDA Libraries ===
On top of the build-in modules above we have also created a bunch of helpful libraries written in python. If you go through the bootstrap process or use the App Library you should always have a full set of those on your badge. If for some reason this isn't the case you can download our repository from https://github.com/emfcamp/Mk4-Firmware and copy the &lt;code&gt;lib&lt;/code&gt; folder onto your badge.

for now please have a look at the libraries themselves: https://github.com/emfcamp/Mk4-Apps/tree/master/lib

(feel free to add additional ideas, and create links new wiki pages to on-going projects, perhaps someone will want to contribute)

=== Hardware ===

Full hardware files are on GitHub [https://github.com/emfcamp/Mk4-Hardware]

== Badge hardware ==

TiLDA comes with a long list of very useful hardware. Some might be obvious, but some are a bit hidden. 
* Texas Instruments [http://www.ti.com/product/MSP432E401Y MSP432E4 SimpleLink Microcontroller] (ARM Cortex-M4F @ 120MHz)
* Texas Instruments [http://www.ti.com/product/CC3120 CC3120 SimpleLink Wi-Fi¬Æ Network Processor]
* 256KB internal RAM / 8MB external SDRAM
* 1MB internal flash (firmware) / 1MB external flash (filesystem)
* [https://simcom.ee/modules/gsm-gprs/sim800c/ SIM800 Quad-band GSM/GPRS module] with Bluetooth support
* [https://cdn.hackaday.io/files/11178478239552/ER-TFT024-3_Datasheet.pdf 240x320 RGB screen]
* 2 [https://cdn-shop.adafruit.com/datasheets/WS2812B.pdf WS2812B RGB LEDs] (aka Neopixels) with a 3-pin header to connect your own (And this year they‚Äôre the right way up!)
* Texas Instruments [http://www.ti.com/lit/ds/symlink/hdc2080.pdf HDC2080 Low Power Humidity and Temperature Sensor]
* Texas Instruments [http://www.ti.com/lit/ds/symlink/tmp102.pdf TMP102 Digital Temperature Sensor]
* Texas Instruments [http://www.ti.com/lit/ds/symlink/opt3001.pdf OPT3001 Digital Ambient Light Sensor]
* Texas Instruments [http://www.ti.com/lit/ds/symlink/drv5055.pdf DRV5055 High Accuracy Bipolar Hall Effect Sensor]
* Speaker and Microphone
* 2000mAh Battery
* Onboard Ethernet (requires breakout)
* A [https://en.wikipedia.org/wiki/T9_(predictive_text) T9] number keypad and a joystick
* 2 [http://wiki.seeedstudio.com/Grove_System/ Seed Studio Grove headers] (one UART, one I¬≤C)
* [https://learn.sparkfun.com/tutorials/sewing-with-conductive-thread Conductive thread] points and 0.1" header for power/UART/I2C/GPIO
* [https://hackaday.io/project/52950-defcon-26-shitty-add-ons Defcon 26 Shitty Add-Ons connector]

Hardware files are available on GitHub [https://github.com/emfcamp/Mk4-Hardware].

[[File:Sensor_graphic_-_with_fixed_transparency-01.png|left|500px|TiLDA Mkùõø Back]]
[[File:Sensor_graphic_-_with_fixed_transparency-02.png|left|500px|TiLDA Mkùõø Back]]
[[Category: Badges]]</text>
      <sha1>mj3875vfbnv7i97ucm1mop71jwg9onx</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/Badge Store Submissions</title>
    <ns>0</ns>
    <id>62</id>
    <revision>
      <id>435</id>
      <parentid>334</parentid>
      <timestamp>2018-09-09T16:24:50Z</timestamp>
      <contributor>
        <username>Davea</username>
        <id>30</id>
      </contributor>
      <comment>/* Headers */</comment>
      <origin>435</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3000" sha1="33jk3tfjy0x3w4z1olb7davrlr7oya9" xml:space="preserve">== Rules for apps in the official badge store ==

* App has to be "Rated G: General Audiences ‚Äì all ages admitted"
* App should not be of malicious nature
* App complies with EMF's [https://www.emfcamp.org/code-of-conduct Code of Conduct]
* No code/image hot-loading without good reasons (since it might be change after the review process)
* It's fine for people to improve on Apps other have written. Likewise, if you submit an App, be aware that others can and will make changes to it.

== Packaging up your badge app for submission to the store ==

Every app becomes a new folder in the root of the Mk4-App GitHub repository. So if you create a "snake" app, you need to put your program files in a folder called "snake" with at least a "main.py" in it.

App names need to be unique (the folder structure enforces that). App folders can contain multiple files (python and non python), but at a minimum "main.py" with the correct headers is required.

Plesae verify that your apps folder structure is correct by running "./tilda_tools validate" (this works without a badge) before submitting it to the badge app store as the validations is also run by Travis to check pull requests.

=== Headers ===

main.py headers:

&lt;pre&gt;
___title___         = "&lt;your_app_name&gt;"
___license___      = "MIT"
___dependencies___ = ["wifi", "http", "ugfx_helper", "sleep"]
___categories___   = ["&lt;see below&gt;"]
___bootstrapped___ = True # Whether or not apps get downloaded on first install. Defaults to "False", mostly likely you won't have to use this at all.
&lt;/pre&gt;

Please use one of these categories:
* System
* Homescreens
* Games
* Sound
* EMF
* Villages
* Phone
* LEDs
* Sensors
* Demo
* Other

== Submitting your badge app to the official badge store ==

* Create a GitHub account [https://github.com/join]
* Download and install git on your local computer [https://git-scm.com/downloads]
* Set up git on your local computer with your username and email address [https://github.com/emfcamp/Mk4-Apps/blob/master/CONTRIBUTING.md#using-git-and-github-to-submit-your-badge-app]
* Fork the emfcamp/Mk4-Apps repo [https://github.com/emfcamp/Mk4-Apps/blob/master/CONTRIBUTING.md#using-git-and-github-to-submit-your-badge-app]
* Clone '''your''' GitHub repo to your computer [https://github.com/emfcamp/Mk4-Apps/blob/master/CONTRIBUTING.md#using-git-and-github-to-submit-your-badge-app] 
* Add your app to your local repo [https://github.com/emfcamp/Mk4-Apps/blob/master/CONTRIBUTING.md#using-git-and-github-to-submit-your-badge-app]
* Create a Pull Request [https://github.com/emfcamp/Mk4-Apps/blob/master/CONTRIBUTING.md#using-git-and-github-to-submit-your-badge-app]

* Over time, your GitHub repo will get out of sync with the changes that have been made to the emfcamp/Mk4-Apps repo so you will need to update your GitHub repo [https://github.com/emfcamp/Mk4-Apps/blob/master/CONTRIBUTING.md#updating-your-github-and-local-git-repo]

If you prefer a GUI interface, you could consider https://desktop.github.com/</text>
      <sha1>33jk3tfjy0x3w4z1olb7davrlr7oya9</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/BuildingFirmware</title>
    <ns>0</ns>
    <id>76</id>
    <revision>
      <id>409</id>
      <parentid>407</parentid>
      <timestamp>2018-09-02T12:15:34Z</timestamp>
      <contributor>
        <username>Drrk</username>
        <id>12</id>
      </contributor>
      <origin>409</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="245" sha1="cndtbv8kc2j3ai92s718qt30jp2l3b1" xml:space="preserve">MacOS and Linux, Windows Builds unknown

git clone --recurse-submodules https://github.com/micropython/micropython.git

cd micropython

git submodule add git@github.com:emfcamp/Mk4-micropython-board.git ports/ti

cd ports/ti

./inst_tools 

make</text>
      <sha1>cndtbv8kc2j3ai92s718qt30jp2l3b1</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/Code Structure</title>
    <ns>0</ns>
    <id>71</id>
    <revision>
      <id>434</id>
      <parentid>369</parentid>
      <timestamp>2018-09-09T16:24:35Z</timestamp>
      <contributor>
        <username>Davea</username>
        <id>30</id>
      </contributor>
      <origin>434</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="750" sha1="0dkhb3ywb4m9ixzoem4mkqax6bew3hz" xml:space="preserve">=== Headers ===

main.py headers:
&lt;pre&gt;
""" &lt;your description&gt;
"""
___title___         = "&lt;your_app_name&gt;"
___license___      = "MIT"
___dependencies___ = ["wifi", "http", "ugfx_helper", "sleep"]
___categories___   = ["&lt;see below&gt;"]
___bootstrapped___ = True # Whether or not apps get downloaded on first install. Defaults to "False", mostly likely you won't have to use this at all.
&lt;/pre&gt;

Please use one of these categories:
* System
* Homescreens
* Games
* Sound
* EMF
* Villages
* Phone
* LEDs
* Sensors
* Demo
* Other

=== Exiting main.py ===

Ensure your apps calls app.restart_to_default() when finished



&lt;pre&gt;
from app import restart_to_default # import at the beginning of your code


restart_to_default() # call on exit of main.py
&lt;/pre&gt;</text>
      <sha1>0dkhb3ywb4m9ixzoem4mkqax6bew3hz</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/Firmware Update</title>
    <ns>0</ns>
    <id>63</id>
    <revision>
      <id>459</id>
      <parentid>458</parentid>
      <timestamp>2019-01-19T23:12:57Z</timestamp>
      <contributor>
        <username>Jontywareing</username>
        <id>77</id>
      </contributor>
      <comment>/* Procedure */</comment>
      <origin>459</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1050" sha1="r8i99wc91li4hxdop487pnqaymcyt9b" xml:space="preserve">While many of the TiLDA apps can be updated via the Badge Store, the base firmware of the badge must be updated over USB.

Updating will provide stability and performance improvements, as well as fixing problems with phone calls.

'''Warning:''' Updating the badge firmware will wipe all apps and settings. Please be sure to have backed up your own code before doing this.

==What you need==
* A computer running OSX, Linux, or Windows equipped with USB ports
* A micro USB cable to connect your badge
* [[TiLDA_MK4/tilda-tools|TiLDA Tools]] installed
* [http://dfu-util.sourceforge.net/ DFU Util] installed

==Procedure==
# Connect the Badge to your computer using the USB cable
# Put your Badge into DFU mode (Press the joystick in - it will click, then press the reset button, then let go of the joystick after a second)
# Run &lt;code&gt;tilda-tools firmware-update&lt;/code&gt; in a terminal (in the location where you installed TiLDA Tools)
# Follow the onscreen information
# Don't forget to press the reset button once the firmware update was successful!</text>
      <sha1>r8i99wc91li4hxdop487pnqaymcyt9b</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/Get Started</title>
    <ns>0</ns>
    <id>73</id>
    <revision>
      <id>453</id>
      <parentid>452</parentid>
      <timestamp>2018-10-27T00:14:18Z</timestamp>
      <contributor>
        <username>Gricey</username>
        <id>76</id>
      </contributor>
      <minor/>
      <comment>/* 5. Your first app */</comment>
      <origin>453</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6391" sha1="klq1aq7d5vkemqieuzj7t46midhirc3" xml:space="preserve">= Get started =

Hacking your TiLDA Mk4 badge is easy. We've written it down step by step. 

If something goes wrong, the badge can be [[TiLDA_MK4/reset|reset]] to its out-of-the-box state, so do not be concerned about breaking anything.

== 1. Connect to your computer ==
To get started you need to connect your badge to a computer. You can use any MicroUSB cable - the same type that charges most mobile phones nowadays. It doesn't matter whether the battery is plugged in or not, so don't worry about it.

== 2. Connect to your badge ==

=== Windows ===
* Please follow the instruction under the "Windows" section on this page: https://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/repl.html
* Once you've installed the driver and Putty and you've connected to your badge, press Control+C to stop the main badge app, and then you should be greeted by a line saying "Micropython"

=== OSX ===
* Click the magnifying class in the top right of your screen and type &lt;code&gt;Terminal&lt;/code&gt; followed by Enter. A white terminal window should appear.
* type &lt;code&gt;screen /dev/tty.usbmodem*&lt;/code&gt; (The * is important, so don't let it out) and hit enter
* hit &lt;code&gt;control+c&lt;/code&gt;, if an error is displayed
* You should now be greeted by a line saying "Micropython"

=== Linux ===
* Open a terminal and type &lt;code&gt;screen /dev/xyz&lt;/code&gt; (todo: please add the correct path)
* You should now be greeted by a line saying "Micropython"

=== What to do if this step doesn't work? ===
* Press the reset button at the back of your badge and try again
* Have a look at https://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/repl.html for more information

== 3. Your first line of Micropython ==

* In your terminal (next to the &gt;&gt;&gt;) type &lt;code&gt;print(1 + 1)&lt;/code&gt; followed by Enter
* You should see &lt;code&gt;2&lt;/code&gt; printed on the screen. Congratulations, you've just written your first line of micropython code!
* You can now close the terminal window (or Putty, if you're on Windows). Note: some serial terminals will not close when the badge is removed or powered off. You should close the serial terminal before plugging the badge back in, otherwise the serial terminal may not reconnect.

== 4. Download some software you'll need ==

You will be downloading some stuff now. It's probably be best if you create some folder somewhere so you don't end up with files all over your Desktop.

Note you can copy files across from your computer to the badge, reset the badge and run the files though the menu, however these instructions make things a little easier.

=== Windows ===
* Python: Go to https://www.python.org/downloads/ and download python version 3.x. After the download is finished you can install it.
* Go to https://bootstrap.pypa.io/get-pip.py and save the file into your folder
* Hold shift, right click on the folder on, and click "open command window here"
* Now type &lt;code&gt;python get-pip.py&lt;/code&gt;
* After the install was successful please type &lt;code&gt;pip install pyserial pyusb&lt;/code&gt; followed by Enter.

=== OSX / Linux ===

* Python: Open a terminal and type &lt;code&gt;python --version&lt;/code&gt;. If you get a version number you're good to go, otherwise go to https://www.python.org/downloads/ and download Python version 3.x. After the download is finished you can install it.
* Go to https://bootstrap.pypa.io/get-pip.py and save the file into your folder
* Use a terminal to go to the folder you created ([http://www.macworld.com/article/2042378/master-the-command-line-navigating-files-and-folders.html this is how you do it]) and type &lt;code&gt;python get-pip.py&lt;/code&gt;
* Now type &lt;code&gt;python get-pip.py&lt;/code&gt;
* After the install was successful please type &lt;code&gt;pip install pyserial pyusb&lt;/code&gt; followed by Enter

=== Problems ===
* If you have problems install python, please use google, there are lots of good explanations out there
* For information about how to install &lt;code&gt;pip&lt;/code&gt; have a look here: https://pip.pypa.io/en/stable/installing/

== 5. tilda_tools ==

You need to clone our Mk4-Apps repository: https://github.com/emfcamp/Mk4-Apps

You might find some tricks on how to do this here: https://badge.emfcamp.org/wiki/TiLDA_MK4/Badge_Store_Submissions#Submitting_your_badge_app_to_the_official_badge_store

There's a python script calle "tilda_tools" in the repository. You can use it to do all sorts of stuff that is a bit complicated to do with the USB mass storage. 

To test it open "adhoc.py" and add the following line at the bottom:
&lt;pre&gt;
ugfx.text(5, 5, "Hello World!", ugfx.RED)
&lt;/pre&gt;

and then run "./tilda_tools run adhoc.py" (or "python tilda_tools run adhoc.py" on Windows)

Todo: test this on windows - what's the best way of running python scripts there?

You should now see "Hello World!" on your screen.

== 5. Your first app ==
Let's create an app you can put on your badge. 

* Open the folder you've downloaded from github - You will see other app folders like "badge_store" and "snake".
* Create a folder called "my_app". This is your new app.
* Open a text editor. On Windows you can search for &lt;code&gt;Notepad&lt;/code&gt;, on OSX there's one called &lt;code&gt;textedit&lt;/code&gt; and if you're on Linux you can probably find one by searching for "edit". 
* Copy the following and save it as &lt;code&gt;main.py&lt;/code&gt; in your folder:

&lt;pre&gt;
"""My first app"""

___title___         = "My app"
___license___      = "MIT"
___dependencies___ = ["ugfx_helper"]
___categories___ = ["Demo"]

import ugfx_helper, ugfx, tilda, sleep
from app import restart_to_default

ugfx_helper.init()
ugfx.clear()

ugfx.text(5, 5, "Hello World", ugfx.RED)
ugfx.fill_circle(100, 100, 30, ugfx.GREEN)
ugfx.fill_circle(200, 100, 30, ugfx.GREEN)
ugfx.area(80, 150, 140, 20, ugfx.GREEN)
ugfx.area(120, 170, 60, 20, ugfx.GREEN)

while tilda.Buttons.is_pressed(tilda.Buttons.BTN_Menu) is False:
    sleep.wfi() # This means sleep for a short while

ugfx.clear()
restart_to_default()
&lt;/pre&gt;

Now you can run "./tilda_tools app my_app" - Wait a few seconds and you should see your app working on the screen. 

It will now work even when the computer is disconnected. To load it you'll have to open it via the Launcher or use the settings app to make it your default app.

== 6. Publish your app to the app library ==

Now that you have your own smiley app, why not share it with others? 

See https://badge.emfcamp.org/wiki/TiLDA_MK4/Badge_Store_Submissions for more information</text>
      <sha1>klq1aq7d5vkemqieuzj7t46midhirc3</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/modtilda</title>
    <ns>0</ns>
    <id>65</id>
    <revision>
      <id>306</id>
      <timestamp>2018-08-29T11:02:29Z</timestamp>
      <contributor>
        <username>Davea</username>
        <id>30</id>
      </contributor>
      <comment>Created page with "todo: spec this out  &lt;pre&gt; &gt;&gt;&gt; import tilda &gt;&gt;&gt; dir(tilda) ['__class__', '__name__', 'Buttons', 'LED', 'Sensors', 'main', 'storage_disable_usb', 'storage_enable_usb'] &gt;&gt;&gt; dir(..."</comment>
      <origin>306</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1046" sha1="g8n79ps97xzz82o25e9ynd2873lc8ov" xml:space="preserve">todo: spec this out

&lt;pre&gt;
&gt;&gt;&gt; import tilda
&gt;&gt;&gt; dir(tilda)
['__class__', '__name__', 'Buttons', 'LED', 'Sensors', 'main', 'storage_disable_usb', 'storage_enable_usb']
&gt;&gt;&gt; dir(tilda.Buttons)
['__class__', '__name__', 'BTN_0', 'BTN_1', 'BTN_2', 'BTN_3', 'BTN_4', 'BTN_5', 'BTN_6', 'BTN_7', 'BTN_8', 'BTN_9', 'BTN_A', 'BTN_B', 'BTN_Call', 'BTN_End', 'BTN_Hash', 'BTN_Menu', 'BTN_Star', 'JOY_Center', 'JOY_Down', 'JOY_Left', 'JOY_Right', 'JOY_Up', 'disable_all_interrupt', 'disable_interrupt', 'disable_menu_reset', 'enable_interrupt', 'enable_menu_reset', 'get_all_states', 'has_interrupt', 'is_pressed', 'is_triggered']
&gt;&gt;&gt; dir(tilda.LED)
['__class__', '__name__', 'GREEN', 'RED', 'off', 'on', 'toggle']
&gt;&gt;&gt; dir(tilda.Sensors)
['__class__', '__name__', 'BAT_ADAPTER_24', 'BAT_DONE_CHARGING', 'BAT_FAST_CHARGING', 'BAT_NOT_CHARGING', 'BAT_NO_INPUT', 'BAT_OTG', 'BAT_PRE_CHARGING', 'BAT_USB_HOST', '_raw_bq', 'get_charge_status', 'get_hdc_humidity', 'get_hdc_temperature', 'get_lux', 'get_tmp_temperature', 'get_vbus_connected', 'sample_rate']
&lt;/pre&gt;</text>
      <sha1>g8n79ps97xzz82o25e9ynd2873lc8ov</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/Neopix</title>
    <ns>0</ns>
    <id>74</id>
    <revision>
      <id>395</id>
      <timestamp>2018-09-01T18:16:38Z</timestamp>
      <contributor>
        <username>Sknebel</username>
        <id>64</id>
      </contributor>
      <comment>code snippet from leaflet</comment>
      <origin>395</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="83" sha1="8lemwi0c7y9b8cnatgok2oas3zs014d" xml:space="preserve">&lt;pre&gt;
from machine import Neopix
n = Neopix()
n.display([0x00ff00,0xff0000])
&lt;/pre&gt;</text>
      <sha1>8lemwi0c7y9b8cnatgok2oas3zs014d</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/reset</title>
    <ns>0</ns>
    <id>61</id>
    <revision>
      <id>343</id>
      <parentid>295</parentid>
      <timestamp>2018-08-30T16:00:23Z</timestamp>
      <contributor>
        <username>Philcrump</username>
        <id>11</id>
      </contributor>
      <minor/>
      <comment>Clarify reset process.</comment>
      <origin>343</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="974" sha1="bgyt7kzf2p0t50le6nlx0r9gyp5uoum" xml:space="preserve">Should your badge stop working there are these ways to fix it. Please make sure you have a backup of whatever you've been working on, you might lose all the data stored on your badge.

Todo: Is there an easier way? 

== Factory reset the badge== 
Press and hold 'MENU' and then briefly press the reset button on the back. Keep the MENU button held down, then release it when both the green and red LED are on at the same time. Both LEDs should flash for a few times. Wait a few seconds until the blinking has stopped and press reset again. 

After that you should finally get a screen saying "Downloading TiLDA software". It should take less than a minute until the badge functionalities are restored, but you will have to re-install your apps.

P.S. The micropython documentation on factory resetting is [http://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/reset.html here]. On the TiLDA MK3 the USR button is the MENU button, and the orange LED is actually red.</text>
      <sha1>bgyt7kzf2p0t50le6nlx0r9gyp5uoum</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/Run Code</title>
    <ns>0</ns>
    <id>72</id>
    <revision>
      <id>450</id>
      <parentid>449</parentid>
      <timestamp>2018-09-18T21:59:50Z</timestamp>
      <contributor>
        <username>Ms7821</username>
        <id>4</id>
      </contributor>
      <minor/>
      <comment>/* Through the REPL */</comment>
      <origin>450</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1494" sha1="jpsm9eflse6imroo7pjgykk2fk78swz" xml:space="preserve">
== Through the REPL ==
* Todo: Please write how to do that on different operating systems
* todo: how to use a REPL

'''Important''': once connected to the serial port, you'll only see output the badge sends (usually none). Hit Ctrl+C to exit from the current process and get back the REPL.

=== Windows/WSL ===
==== Identify serial device ====
The serial device should be a COM port that only shows when you plug the badge in, e.g. COM4:
# Open Computer Management (compmgmt.msc)
# Navigate to Device Manager
# Expand Ports (COM &amp; LPT)

Alternatively in PowerShell:

 Get-WMIObject Win32_SerialPort | select DeviceID,Description

==== Connect to identified device ====
Open PuTTY, enter the COM port found above, e.g. COM4, select Serial, and click Open.

Alternatively in WSL:

 sudo screen /dev/ttyS{n}

where {n} is the numeric part of the COM port (e.g. /dev/ttyS4 for COM4). Use Ctrl+A, D to disconnect.

== Use the "mass storage" app ==
* Only works on OSX at present (2nd Sept 2018)
* easy to do
* make sure to safely eject every time
* has a tendency to corrupt the filesystem - link to reset instructions
* hard to debug errors
* todo: add more information

== Use Mk4-Apps tilda_tools ==
* Probably most convenient, but a bit more involved:
* You can use "./tilda_tools run &lt;file.py&gt;" to run code without copying anything, but if you want to make sure you have all your libraries updated use "./tilda_tools app my_app" instead.
* https://badge.emfcamp.org/wiki/TiLDA_MK4/tilda-tools</text>
      <sha1>jpsm9eflse6imroo7pjgykk2fk78swz</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/sensors</title>
    <ns>0</ns>
    <id>67</id>
    <revision>
      <id>479</id>
      <parentid>362</parentid>
      <timestamp>2023-08-22T12:45:06Z</timestamp>
      <contributor>
        <username>CircuitCamps</username>
        <id>84</id>
      </contributor>
      <minor/>
      <comment>/* Overview */</comment>
      <origin>479</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5471" sha1="lpuhk2wg6mze3q81ksrg0m03udd2pon" xml:space="preserve">== Overview ==

The TiLDA MK4 has four sensors, three sharing an [https://www.allaboutcircuits.com/technical-articles/introduction-to-the-i2c-bus/ I2C bus] and one with an analog output:

* Temperature and Humidity: [http://www.ti.com/product/HDC2080 TI HDC2080]
* Luminance: [http://www.ti.com/product/OPT3001 TI OPT3001]
* Temperature: [http://www.ti.com/product/TMP102 TI TMP102] - the TMP102 has higher precision and extended temperature range with no calibration needed compared to HDC2080
* Magnetic: [http://www.ti.com/product/DRV5055 TI DRV5055]

The sensors are physically located on the badge as shown in the picture below. Since these are environmental sensors, the orientation and location of the badge will affect the values returned from the sensors. For example, wearing the badge close to your body will likely raise the temperature readings.
 
[[File:Sensor graphic - with fixed transparency-01.png|400px]]
[[File:Sensor graphic - with fixed transparency-02.png|400px]]

In addition, the battery charger circuit (TI BQ25601), powered via USB, has status available via the I2C bus.

These sensors are managed by the tilda.Sensors module. This module takes care of initializing the devices and periodically updating readings from them. This makes it easier to use from applications as all the low-level interactions and data formatting are available directly via MicroPython methods. There are more features available in the devices that could be enabled. Currently this would be done by enhancing the C code in the ports/ti directory. In the future, the devices might also be directly programmable via the MicroPython I2C API.

You can see what's provided by the Sensors module using the standard Python dir() operator:

&lt;pre&gt;
&gt;&gt;&gt; from tilda import Sensors
&gt;&gt;&gt; dir(Sensors)
['__class__', '__name__', 'BAT_ADAPTER_24', 'BAT_DONE_CHARGING', 'BAT_FAST_CHARGING', 'BAT_NOT_CHARGING', 'BAT_NO_INPUT', 'BAT_OTG', 'BAT_PRE_CHARGING', 'BAT_USB_HOST', '_raw_bq', 'get_charge_status', 'get_hdc_humidity', 'get_hdc_temperature', 'get_lux', 'get_tmp_temperature', 'get_vbus_connected', 'sample_rate']
&lt;/pre&gt;

Per the usual Python conventions, the all upper-case identifiers are symbolic constant values. The other identifiers are methods that should be semi-obviously apparent in what functions they perform.

== Temperature and Humidity ==

Two methods are provided for the HDC2080. get_hdc_temperature() returns the current ambient temperature in degrees Centigrade. get_hdc_humidity() returns the relative humidity as a percentage.

get_tmp_temperature() returns the current ambient temperature in degrees Centigrade from the TMP102 sensor.

&lt;pre&gt;
from tilda import Sensors

print("HDC temperature: {} C".format(Sensors.get_hdc_temperature()))
print("TMP temperature: {} C".format(Sensors.get_tmp_temperature()))
print("HDC humidity: {}%".format(Sensors.get_hdc_humidity()))
&lt;/pre&gt;

== Luminance ==

The OPT3001 measures light intensity (luminance) scaled to match the way the human eye perceives light. This is useful for applications controlling lighting so that changes appear more natural to people.

&lt;pre&gt;
from tilda import Sensors
from time import sleep

while True:
    print("Light intensity: {} lux".format(Sensors.get_lux()))
    sleep(1)
&lt;/pre&gt;

Place your hand over the OPT3001 sensor and observe the measured intensity change.

== Magnetic Flux - Hall Effect ==

The DRV5055 senses magnetic fields (hooray for ElectroMAGNETIC FIELD Camp!). The device provides an analog output that is sampled by the ADC on the MCU. The particular device on the badge has a sensitivity of 12.5mV / mT. Note that the earth's magnetic field is in the range of micro Teslas (uT). Bring a small magnetic close to the sensor and watch the measurements change.

&lt;pre&gt;
from machine import ADC
from time import sleep_ms

mag = ADC(ADC.ADC_HALLEFFECT)
while True:
    print(mag.convert())
    sleep_ms(200)
&lt;/pre&gt;

== Battery ==

The BQ25601 takes care of charging the LiPo battery when the badge is attached to a USB power source - PC, car, battery. You can monitor the status by using the get_charge_status() and get_vbus_connected() methods. For example, you might want to turn off the display more often when there is no USB power so that the battery lasts longer.

&lt;pre&gt;
from tilda import Sensors
from machine import Pin

backlight = Pin(Pin.PWM_LCD_BLIGHT)
if Sensors.get_vbus_connected() != Sensors.BAT_NO_INPUT:
    backlight.on()
&lt;/pre&gt;

While there is power supplied via USB, you can monitor the charging status:

&lt;pre&gt;
from tilda import Sensors

charging = Sensors.get_charge_status()
if charging == Sensors.BAT_PRE_CHARGING or charging == Sensors.BAT_FAST_CHARGING:
    print("Battery is charging")
elif charging == Sensors.BAT_DONE_CHARGING:
    print("Battery is full")
elif charging == Sensors.BAT_NOT_CHARGING:
    print("Battery is discharging")
&lt;/pre&gt;

== Sample Rate ==

You can change how often the sensors are read using the sample_rate() method. Like other Python APIs, this function is both a "setter" and a "getter". If you call it with no argument, it returns the current sample rate in Hz. If you supply a value, the sample rate is changed. Changing the sample rate can let you see sensor values change more rapidly; conversely, a slower sample rate will update less often but use less energy, making the battery last longer.

&lt;pre&gt;
from tilda import Sensors

print("Sensor sample rate: {}".format(Sensors.sample_rate()))
Sensors.sample_rate(2)
&lt;/pre&gt;</text>
      <sha1>lpuhk2wg6mze3q81ksrg0m03udd2pon</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/sim800</title>
    <ns>0</ns>
    <id>66</id>
    <revision>
      <id>417</id>
      <parentid>363</parentid>
      <timestamp>2018-09-03T10:42:01Z</timestamp>
      <contributor>
        <username>Mouseboks</username>
        <id>68</id>
      </contributor>
      <minor/>
      <origin>417</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="21726" sha1="tgayi5r55z7t5g4i3lwto6rc8h0mdjz" xml:space="preserve">== Overview ==

The TiLDA MK4 is equipped with an SIM800C module. This is primarily a GSM module for communication with a mobile network. It also has many other features including Bluetooth, a file system and some audio features.

Below are the features and functions exposed thought this library.

== Calling ==

=== Call ===

&lt;code&gt;sim800.call(number)&lt;/code&gt;

* number = Number to call. This can be an integer but you will need ti use a string if your number has a "0" prefix

=== Answer Call ===

&lt;code&gt;sim800.answer()&lt;/code&gt;

=== End/Reject Call ===

&lt;code&gt;sim800.hangup()&lt;/code&gt;

=== Redial ===

&lt;code&gt;sim800.redial()&lt;/code&gt;

== Settings ==

=== Ringer Volume ===

&lt;code&gt;sim800.ringervolume([level])&lt;/code&gt;

* level: If set the volume as a percentage is changed to that value. If not set the volume will not change.

The current (possibly new) volume level is returned.

=== Speaker Volume ===

&lt;code&gt;sim800.speakervolume(level)&lt;/code&gt;

* level: If set the volume as a percentage is changed to that value. If not set the volume will not change.

The current (possibly new) volume level is returned.

=== Ringtone ===

The SIM800 has 19 terrible ringtones. You can select any of them. My federate is 0 that is also silent.

&lt;code&gt;sim800.ringtone([alert],[preview])&lt;/code&gt;

* alert: The number of the new ringtone (0-19).
* preview: If True it will play. If False or absent then it will stop.

The current (possible new) ringtone is returned. The ringtone is always changed regardless of the preview setting.

=== Ringing ===

&lt;code&gt;sim800.isringing()&lt;/code&gt;

Returns True if ringing.

The sim800.getstatus() also returns 2 when ringing and machine.Pin(machine.Pin.GPIO_SIM_RI, machine.Pin.IN).value() will show the start of the hardware ringer indicator pin. You an also user a callback (documented below) with the call name of "RING".

&lt;code&gt;sim800.latestnumber()&lt;/code&gt;

Returns the number of the current caller if ringing. Returns the number of the last caller if not ringing.

=== Play DTMF ===

&lt;code&gt;sim800.dtmf(number)&lt;/code&gt;

Plays DTMF tones on an active call.

* number: The number of the tone to play. This can a string of numbers that are played in sequence. Using "," will pause for one second. (int or str)

== SMS ==

=== List SMS Messages ===

&lt;code&gt;sim800.listsms([stat])&lt;/code&gt;

List available SMS messages.

* stat:
*: 0 = received unread messages (default)
*: 1 = Received read messages
*: 2 = Stored unsent messages
*: 3 = Stored sent messages
*: 4 = All message

&lt;code&gt;sim800.newsms()&lt;/code&gt;

Returns True if you have a new (unread) SMS message

=== Read an SMS Message ===

&lt;code&gt;sim800.readsms(index, leaveunread)&lt;/code&gt;

* index: The index of the message to read. This can be found by calling sim800.listsms().
* leaveunread: If set to True the message will remain flagged as unread if it was to start with. If False (default) then it will be marked as read.

If you are looking for a message to process consider setting leaveunread to True until you identify the message is for you or the user will continually find all there messages are read.

The contents of the message is returned as a string.

=== Send an SMS Message ===

&lt;code&gt;sim800.sendsms(number, message)&lt;/code&gt;

* number: The number to send the SMS message to.
* message: The message to send as a string. This must be less than 160 8-bit charicters in length.

=== Delete an SMS Message ===

&lt;code&gt;sim800.deletesms(index)&lt;/code&gt;

index: The index of the message to delete. This can be found by calling sim800.listsms().

== File System ==

The SIM800 module has around 90KB of file storage. This can be used to store files to send to or receive from and paired Bluetooth device as well as for audio recordings.

=== Free Space ===

&lt;code&gt;sim800.fsfree()&lt;/code&gt;

Returns the number of bytes available in the file system.

=== List Directory ===

&lt;code&gt;sim800.fsls([directory])&lt;/code&gt;

* directory: The directory on the file system relative to root to list. Directories end with a backslash. The root directory is returned if no parameter is given.

A list of file names is returned. Directories end with a "\". Don't forget to escape this as "\\" in your code.

=== File Size ===

&lt;code&gt;sim800.fssize(filename)&lt;/code&gt;

* filename: The directory and filename of the file.

The size of the file in bytes. A size of -1 is returned if the file does not exist.

=== Create Directory ===

&lt;code&gt;sim800.fsmkdir(directory)&lt;/code&gt;

Creates a directory.

* directory: The name of the directory to create.

=== Remove Directory ===

Removes a directory.

&lt;code&gt;sim800.fsrmdir(directory)&lt;/code&gt;

* directory: The name of the directory to delete.

=== Create a file ===

&lt;code&gt;sim800.fscreate(filename)&lt;/code&gt;

Creates an empty file.

* filename: The filename of the file (including directory) to create.

=== Read From File ===

&lt;code&gt;sim800.fsread(filename)&lt;/code&gt;

Returns the contents of the file.

* filename: The filename of the file (including directory) to read.

Note that this can be slow. You may want to use sim800.uartspeed(460800) to speed things up but you are advised to call sim800.uartspeed(0) after to switch back to automatic.

=== Write To File ===

&lt;code&gt;sim800.fswrite(filename, data, [truncate])&lt;/code&gt;

* filename: The filename of the file (including directory) to read.
* data: The data to write to the file
* truncate: If True the original file emptied first. If False data is appended to the end of the file. Defaults to False.

Note that this can be slow. You may want to use sim800.uartspeed(460800) to speed things up but you are advised to call sim800.uartspeed(0) after to switch back to automatic.

=== Delete File ===

&lt;code&gt;sim800.fsrm(filename)&lt;/code&gt;

* filename: The filename of the file to delete.

=== Rename File ===

&lt;code&gt;sim800.fsmv(from, to)&lt;/code&gt;

Rename a file.

* from: The old filename.
* To: The new filename.

== Bluetooth ==

=== Power and Status ===

&lt;code&gt;sim800.btpoweron()&lt;/code&gt;

Turn on Bluetooth. You may also want to call sim800.btvisible(True) to make your badge discoverable.

&lt;code&gt;sim800.btpoweroff()&lt;/code&gt;

Turn of Bluetooth.

&lt;code&gt;sim800.btison()&lt;/code&gt;

Returns True if Bluetooth is turned on.

&lt;code&gt;sim800.btstatus()&lt;/code&gt;

This returns the status of the Bluetooth stack:
:0 = Initial (Not powered on)
:1 = Disactivating
:2 = Activating
:5 = Idle (Normal and waiting)
:6 = Inquiry
:7 = Inquiry Res Ind
:8 = Cancelling inquiry
:9 = Bonding
:11 = Pairing
:12 = Connecting
:14 = Deleting paired device
:15 = Deleting all paired device
:19 = Pairing confirm while passive pairing

&lt;code&gt;sim800.btrssi(device)&lt;/code&gt;

* device: The device to check. This can be obtained using sim800.btpaired().

Returns the signal quality for the device (-127-0)

=== Settings ===

&lt;code&gt;sim800.btname([name])&lt;/code&gt;

Get and Set the Bluetooth name for your badge.

* name: The new name of your badge. Omit this to just read the current setting.

Returns the name (possubly the new name) of the badge.

&lt;code&gt;sim800.btaddress()&lt;/code&gt;

Returns the Bluetooth address of the badge.

=== Pairing ===

Before you can use other devices over Bluetooth or they can use you you will first need to pair the device.

You can pair to most devices. This includes hands free kits for making calls thought your badge.

&lt;code&gt;sim800.btvisible([visible])&lt;/code&gt;

* visible: If True the badge is visible to other Bluetooth devices.

&lt;code&gt;sim800.btscan([timeout])&lt;/code&gt;

Scan for other Bluetooth devices.

* Timeout: Time in milliseconds to search. 10000 to 60000 in increments of 10000. Defaults to 30000.

Returns a list of device IDs, Names, address, and the rssi of the discovered devices.

&lt;code&gt;sim800.btpair(device)&lt;/code&gt;

Request a pairing with another device.

* device: The ID of the device returned from sim800.btscan().

You will then need to confirm the pairing with sim800.btpairconfirm().

&lt;code&gt;sim800.btpairconfirm([passkey])&lt;/code&gt;

This should only be called once the user has confirmed that the value of sim800.btparingpasscode() is the same number as displayed on the other device.

* passkey: If your pairing needs a passkey to be entered. This is an old 4 figure pin for compatibility should not be confused with the 6 figure code shown on the other device.

You can monitor for incoming pairing requests using the callbacks documented below.

&lt;code&gt;sim800.btpairreject()&lt;/code&gt;

Reject an incoming pairing request.

&lt;code&gt;sim800.btparingname()&lt;/code&gt;

Returns the name of the device trying to pair with you.

&lt;code&gt;sim800.btparingpasscode()&lt;/code&gt;

Returns the passcode that the user should check against the screen on the other device. 

&lt;code&gt;sim800.btunpair([device])&lt;/code&gt;

Unpair a Bluetooth device.

* device: The ID of the device to unpair. This can be found by calling sim800.btpaired(). 0 to unpair everything.

&lt;code&gt;sim800.btpaired()&lt;/code&gt;

Returns a list of paired devices.

=== Connecting ===

Once a device is paired you can connect them using a profile to do something useful. please check the SIM800 documentation listed at the bottom to check what is supported by the SIM800C on the MK4 badge.

&lt;code&gt;sim800.btgetprofiles(device)&lt;/code&gt;

* device: The device to check. This can be obtained using sim800.btpaired().

Returns a list of supported profiles a paired device supports.

&lt;code&gt;sim800.btprofilesupported(device, profile)&lt;/code&gt;

Check if a specific profile is supported by a device.

* device: The device to check. This can be obtained using sim800.btpaired(). 
* profile: The name (string) or ID (integer) of the profile.

Returns True if it is supported.

&lt;code&gt;sim800.btconnect(device, profile)&lt;/code&gt;

* device: The device to connect. This can be obtained using sim800.btpaired(). 
* profile: The ID (integer) of the profile to connect.

&lt;code&gt;sim800.btdisconnect(device)&lt;/code&gt;

* device: The profile dosconnect. This can be obtained using sim800.btconnected(). 

&lt;code&gt;sim800.btconnected()&lt;/code&gt;

Returns a list of connected profiles.

=== Object Push Profile (OPP) ===

This is used to transfer files over Bluetooth. This will transfer files between the internal storage that is limited to about 90K) and other devices. See the File System section for how to transfer data to and from the file system.

&lt;code&gt;sim800.btopppush(device, filename)&lt;/code&gt;

Send a file to another device.

* device: The device ID. This can found using sim800.btpaired().
* filename: The full filename (including directory) if the file to send.

&lt;code&gt;sim800.btoppaccept()&lt;/code&gt;

Accept an incoming file from a paired device.

You can get notification of an incoming connection by monitoring "+BTOPPPUSHING:" using the callbacks feature. Files stored in "\\User\\BtReceived".

&lt;code&gt;sim800.btoppreject()&lt;/code&gt;

Reject a file being offered by another device.

=== Serial Port Profile (SPP) ===

This allows serial communication with a paired device. At the time of writing this has been written to specification and has not been tested. We hope to have this tested in time but please report any issues to @alistair.

&lt;code&gt;sim800.btsppwrite(connection, data)&lt;/code&gt;

* connection: The ID of the connected device.
* data: The data to send.

&lt;code&gt;sim800.btsppread(connection)&lt;/code&gt;

* connection: The ID of the connected device.

Any received data is returned as a string.

=== Bluetooth Calling ===

These allow use of phones features over Bluetooth.

&lt;code&gt;sim800.btcall(number)&lt;/code&gt;

* number: The number to call

&lt;code&gt;sim800.btanswer()&lt;/code&gt;

Answer an incoming call.

&lt;code&gt;sim800.bthangup()&lt;/code&gt;

End or reject a call

&lt;code&gt;sim800.btredial()&lt;/code&gt;

Redial the last number

&lt;code&gt;sim800.btdtmf(number)&lt;/code&gt;

Send DTMF tones.

* number: The number to send.

&lt;code&gt;sim800.btvoicevolume([gain])&lt;/code&gt;

* gain: The volume of the speaker (0-15). Will remain unchanged if omitted.

Returns the volume if changed or not.

&lt;code&gt;sim800.btvoicevolume([gain])&lt;/code&gt;

* gain: The gain of the microphone (0-15). Will remain unchanged if omitted.

Returns the gain if changed or not.

== Audio ==

=== Play Tone ===

&lt;code&gt;sim800.playtone([freq],[duration],[async])&lt;/code&gt;

* freq: The frequency to play in Hz.
* duration: The duration of the tone in milliseconds.
* async: If True (dafault) it will return instantly and the audio will continue to play for the duration.

=== Record Audio ===

&lt;code&gt;sim800.startrecording([id],[length])&lt;/code&gt;

* id: The ID of the recording (1-10). Defaults to 1.
* length: The maximum duration of the audio to record in ms. No limit if not set.

&lt;code&gt;sim800.stoprecording()&lt;/code&gt;

Stop recording audio.

=== Playback recordings ===


&lt;code&gt;sim800.startplayback([id], [channel], [level], [repeat])&lt;/code&gt;

* id: The ID of the recording (1-10). Defaults to 1.
* channel: The device to play back on. 0 is the speaker.
* level: Volume to play back at as a percentage.
* repeat: If True the audio will loop.

&lt;code&gt;sim800.stopplayback()&lt;/code&gt;
# Stop playback

Stop playing back audio.

=== Manage Recordings ===

Although the recordings show up in the file system you will need to use these functions to manage them.

&lt;code&gt;sim800.listrecordings()&lt;/code&gt;

Returns an array of the stored recordings.

&lt;code&gt;sim800.deleterecording([id])&lt;/code&gt;

* id: The ID of the recording (1-10). Defaults to 1.

== System, Network and Status ==

=== Power ===

The SIM800 module will be powered up when the library is first loaded. You can turn it on and off if you want.

&lt;code&gt;sim800.ison()&lt;/code&gt;

Returns true if the SIM800 is powered up.

&lt;code&gt;sim800.poweron([async])&lt;/code&gt;

* async: If True it will return immediately and power on in the background. If False (default) it will wait until it has booted before returning.

True is returned of the SIM800 if turned on.

&lt;code&gt;sim800.poweroff([async])&lt;/code&gt;

* async: If True it will return immediately and power on in the background. If False (default) it will wait until it has powered off before returning.

True is returned of the SIM800 if turned off.

=== Battery ===

&lt;code&gt;sim800.batterycharging()&lt;/code&gt;

Returns true of the battery is charging.

&lt;code&gt;sim800.batterycharge()&lt;/code&gt;

Returns the percentage charge of the battery.

=== Network and SIM Information ===

&lt;code&gt;sim800.getstatus()&lt;/code&gt;

Gets the status of the SIM800.
    
Returns:
:0 = Ready
:2 = Unknown:
:3 = Ringing
:4 = Call in progress
	
&lt;code&gt;sim800.imei()&lt;/code&gt;
	
Return the IMEI (International Mobile Equipment Identity) of the badge.

&lt;code&gt;sim800.imsi()&lt;/code&gt;

Return the IMSI (International mobile subscriber identity) of the SIM.

&lt;code&gt;sim800.iccid()&lt;/code&gt;

Returns the SIM card's unique serial number.

&lt;code&gt;sim800.ussd(ussdstring, [timeout])&lt;/code&gt;

Request Unstructured Supplementary Service Data from network (*#xxxxxx#)

* ussdstring: The command. "*#100#" for example
* timeout: Time to wait in milliseconds.

&lt;code&gt;sim800.getmynumber()&lt;/code&gt;

Get the telephone number from the network. This only works with some networks and may be formatted text.

&lt;code&gt;sim800.rssi()&lt;/code&gt;

Return the Received Signal Strength Indication (signal strength) of the current cell communication.

* 0: -115 dBm
* 1: -111 dBm
* 2...30: -110...-54 dBm
* 31:: -52 dBm
* &gt;99: No signal

&lt;code&gt;sim800.ber()&lt;/code&gt;

Returns the Bit Error Rate (signal quality) of the current cell communication. Percent value.

&lt;code&gt;sim800.cellid()&lt;/code&gt;

Returns the Cell ID of the currently connected cell tower.

&lt;code&gt;sim800.engineeringinfo([neighbour])&lt;/code&gt;

* neighbour: Include full neighbouring cell information if True.

Returns the engineering information (documented in the docuemtns listed in the advanced section) for the current cell and 6 neighbouring cells.

=== Network selection ===

&lt;code&gt;sim800.listoperators([available_only])&lt;/code&gt;

* available_only: If True (default) only the networks you can connect to are listed.

A list of arrays is returned with the following parameters.
: 1=available,2=current,3=forbidden
: Long name
: Short name
: GSMLAI

&lt;code&gt;sim800.currentoperator(format)&lt;/code&gt;

* format: The format to return the data in. 0=Long name, 1=Short name, 2=GSMLAI

Returns the current operator.

&lt;code&gt;sim800.setoperator(mode, [format], [operator]&lt;/code&gt;

This can be used to change the operator. It can also make +COPS calls to the SIM800.

* mode: 0=automatic,1=Manual selection,2=deregister only,4=try manual then automatic if fails])
* format: Format of the operator parameter. 0=Long name, 1=Short name, 2=GSMLAI
* operator: The operator to use.

If you mess things up then sim800.setoperator(0) will reset to defaults. sim800.setoperator(1,3,"23404") will force you on to the EMF Camp network.

== Callbacks ==

=== Register for a Callback ===

&lt;code&gt;sim800.call(call, function)&lt;/code&gt;

You can register a function that is called when a response is sent by the SIM800. This allows you to detect calls, incoming messages, Bluetooth requests and other advanced responses.

* call: The response call to be watched for
* function: The function to be called.

The function must take one string parameter. This parameter contains the the parameters sent from the SIM800. You pass the function by it's name without the training brackets.

Some example calls are;

* "RING" - Triggered when an incoming call is detected.
* "+CLIP:" - When caller line identification is received (ie the caller's number).
* "+CMT:" - A new SMS message is received.
* "+DTMF:" - A DTMF tone is detected.
* "+BTPAIRING:" - A Bluetooth pairing request.

For "RING" the parameter will always be an empty string but your function must accept it. When this is triggered the library the callers number may not be valid and "+CLIP:" should be used instead.

Take care not to change things the active app will be using such as the string. This call will be in the same thread but may happen in the middle of another function. If odd things start happening with anything on the badge then try disabling your callbacks is a good thing to try.

=== Deregister from a Callback ===

&lt;code&gt;sim800.deregistercallback(function)&lt;/code&gt;

* function: The function that was used when registering for the callback.

== Advanced  ==

=== UART Speed ===

The communication with the SIM800 autosuggestion by default and we default to 115200 for speed and reliability. You can set the speed to other bauds with the following command.

&lt;code&gt;sim800.uartspeed(newbaud)&lt;/code&gt;

* newbaud: The speed of the internal communication. Valid values are 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400 and 460800. 0 To revert to default.

If the badge is rebooted but not power cycled then the speed can get out of sync. Consider switching back to auto when you can to prevent issues related to this.

=== Custom SIM800 Command Calls ===

&lt;code&gt;sim800.command([command], [response_timeout], [required_response], [custom_endofdata])&lt;/code&gt;

* command: The AT command to send. A full set of of these commands are available in the SIMCom documentation. Links to the most useful ones are below.
* response_timeout: The time to wait for a response in milliseconds.
* required_response: The start of a response we will keep waiting for. If not found in time we will receive a "TIMEOUT"
* custom_endofdata: The start of a response we want for data sent after an "OK" or "ERROR" response.

This returns an array that should start with an echo of the command sent and normally ends with a response identifying if the call was successful. If a required_response or custom_endofdata is specified then this will be the last line. If such a response has not been received before the timeout a response of "TIMEOUT" is sent.

As other apps may be monitoring the SIM800 for data relevant to them. Please do not access the UART directly unless you really have to. If you want to receive then use the callback above and call sim800.processbuffer() to process the incoming data. If you really have to then you can access the UART directly via sim800.uart.

Further details about the AT commands can be found in the following documents.

* [https://cdn-shop.adafruit.com/datasheets/sim800_series_at_command_manual_v1.01.pdf SIM800 Series AT Command Manual]
* [https://cdn-shop.adafruit.com/product-files/2637/SIM800+Series_Bluetooth_Application_Note_V1.04.pdf SIM800 Series Bluetooth Application Note]
* [https://cdn-shop.adafruit.com/product-files/2637/SIM800+Series_FS_Application+Note_V1.01.pdf SIM800 Series FS Application Note]

=== Helper Functions ===

There are also some helper functions that you might find useful.

&lt;code&gt;sim800.sim800.ispositive(response)&lt;/code&gt;

* response: The last line of data returned from sim800.command().

Returns True if it was positive such as "OK" or "CONNECTED".

&lt;code&gt;sim800.isnegative(response)&lt;/code&gt;

* response: The last line of data returned from sim800.command().

Returns True if it was negative such as "ERROR" or "NO CARRIER".

&lt;code&gt;sim800.extractval(parameter, response, [default])&lt;/code&gt;

This looks for the first occurrence of a parameter passed back from the SIM800.

The value of the parameter is returned as a string, or the default if it is not found.

* parameter: The parameter you are looking for. "+GCAP:" for example.
* response: The response from sim800.command()
* default: The value to return if the parameter is not found. Defaults to an empty string.

&lt;code&gt;sim800.extractvals(parameter, response)&lt;/code&gt;

This looks for the occurrences of a parameter passed back from the SIM800.

An array of values of the parameters are returned.

* parameter: The parameter you are looking for. "+CENG:" for example.
* response: The response from sim800.command()

=== Firmware ===

&lt;code&gt;sim800.getfirmwarever()&lt;/code&gt;

Returns the firmware version installed on the SIM800. If it does not end with "_BT" then your Bluetooth will not work. Drop in to the badge tent or contact the badge team online for help.</text>
      <sha1>tgayi5r55z7t5g4i3lwto6rc8h0mdjz</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/sim800/Reverse engineering</title>
    <ns>0</ns>
    <id>68</id>
    <revision>
      <id>354</id>
      <timestamp>2018-08-30T21:14:42Z</timestamp>
      <contributor>
        <username>Renze</username>
        <id>58</id>
      </contributor>
      <comment>Add page about reverse engineering efforts</comment>
      <origin>354</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1205" sha1="qfw4hgocpekf9gna7de7dc2b8jj844u" xml:space="preserve">This page represents an effort to find out more about the inner workings of the SIM800 module found on the TiLDA MK4 badge.

Feel free to add your own research, but please do not remove content added by other people, even if you determined the information to be false.
Instead you could add text explaining why the existing content was wrong.

== Usefull links ==
Page with firmware, update tool and instructions: https://www.raviyp.com/embedded/214-learn-how-to-update-the-firmware-of-your-sim800-modules
Information about Mediatek chipsets: https://www.bunniestudios.com/blog/?p=4297
Information on Mediatek file formats: https://wiki.postmarketos.org/wiki/Mediatek#Image_format

== Current state of research ==
Based on the flashing utility and firmware file provided on the raviyp website the SIM800 module probably contains a Mediatek dumb-phone chipset. Bunny did some research on those already, which can be found on his [[https://www.bunniestudios.com/blog/?p=4297|blog]].

== To-do list ==
 - Removing the lid from a SIM800 module and taking photos of the insides
 - Figuring out exactly which (Mediatek) chip is inside the SIM800
 - Find a way to replace the built-in ringtones
 - ???
 - Profit!</text>
      <sha1>qfw4hgocpekf9gna7de7dc2b8jj844u</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/tilda-tools</title>
    <ns>0</ns>
    <id>64</id>
    <revision>
      <id>443</id>
      <parentid>415</parentid>
      <timestamp>2018-09-14T13:33:02Z</timestamp>
      <contributor>
        <username>GavinAtkinson</username>
        <id>73</id>
      </contributor>
      <origin>443</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2801" sha1="dr78d19upaebe5rryj77yfak8fw0rdj" xml:space="preserve">''tilda_tools'' is a toolchain for working with the micropython environment on the badge.

== Dependencies ==

* Python 3
* pyserial
* dfu-util (only needed for reflashing firmware)

== Installation ==

* Clone the Mk4-Apps repo from https://github.com/emfcamp/Mk4-Apps/ (see [https://help.github.com/articles/cloning-a-repository/ Cloning a repository] for help). Alternatively you can download a ZIP file from the repository page. 

* Open a terminal in the Mk4-Apps/ directory. ''tilda_tools'' is in the root of this directory.

* Windows Users - you will need to install Pyserial to get some commands working - Instructions [https://badge.emfcamp.org/wiki/TiLDA_MK4/Get_Started here]

== tilda-tools ==

&lt;pre&gt;tilda_tools &lt;options&gt;&lt;/pre&gt;

Windows users, create/update a tilda_tools.bat windows batch file, containing the following:
&lt;pre&gt;
@echo off
python %CD%/.development\tilda_tools.py %*
&lt;/pre&gt;
This batch file massively simplifies previous versions, but some things may still not work, depending upon whether you can get the driver to work.

&lt;pre&gt;
Parameters
-----------------

-d --device  : serial interface (default: auto)
-s --storage : path to flash storage

Usage
------------------------------------

Reboot badge
$ tilda_tools reset

Soft reboot badge and start specific app
$ tilda_tools reset --boot my_app

Update files on the badge to match the current local version, restarts afterwards
$ tilda_tools sync

Notes for tilda_tools sync:

1. You will probably want to delete the apps you don't want before doing this.  There are a lot of apps now and they will take up valuable file space and may well use it all up, crashing the badge.
2. You may want to delete bootstrap.py otherwise, when you reset the badge, it will ask you to connect to wifi and then it will download from the server. i.e. it's like doing a factory reset.
3. Consider syncing a single app

Update files in folder(s) to match current local version
$ tilda_tools sync my_game shared
$ tilda_tools sync &lt;pattern1&gt; &lt;pattern2&gt; ...

Sync (as above), but execute my_app after reboot
$ tilda_tools sync --boot my_app [&lt;other sync parameter&gt;]

Sync (as above), but execute a single file afterwards without copying it to the badge
$ tilda_tools sync --run some_other_file.py

Sync a given app and execute it
$ tilda_tools app home_default

Executes a single file on the badge without copying anything (Using pyboard.py)
$ tilda_tools run my_app/main.py

Runs local validation (doesn't require a badge, but doesn't run unit tests)
$ tilda_tools validate

Runs local validation and badge-side tests
$ tilda_tools test

Update firmware on badge (warning, this will delete all settings etc. stored on the badge!)
$ tilda_tools firmware-update

Setup wifi.json to be copied to the badge on every sync
$ tilda_tools wifi
&lt;/pre&gt;</text>
      <sha1>dr78d19upaebe5rryj77yfak8fw0rdj</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MK4/ugfx</title>
    <ns>0</ns>
    <id>60</id>
    <revision>
      <id>451</id>
      <parentid>442</parentid>
      <timestamp>2018-09-25T16:47:36Z</timestamp>
      <contributor>
        <username>Jediminer543</username>
        <id>75</id>
      </contributor>
      <comment>ImageBox is infact Imagebox on the api because reasons</comment>
      <origin>451</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="14995" sha1="029irwzclpoggzps28wnci2t1qryjio" xml:space="preserve">The badge makes use of [http://ugfx.io uGFX] for providing drawing functions on the LCD. Most of this functionality is available through the micropython interface, and you may wish to browse the [https://wiki.ugfx.io/index.php/Main_Page  uGFX documentation] for more details.

To discover exactly which ugfx calls are available in micropython, see https://github.com/emfcamp/micropython/blob/tilda-master/stmhal/modugfx.c

== Basic usage ==

uGFX is comprised of 'widgets,' such as buttons and labels, and 'containers' which are used to group widgets.

To create a button on the screen, use &lt;code&gt;ugfx.Button(x,y,width,height,text)&lt;/code&gt;, and a button will be drawn on the screen.

As well as widgets, there are 'primitives' such as drawing circles and lines, which can be drawn anywhere on the screen or in a container.
For example &lt;code&gt;ugfx.circle(50,50,20,ugfx.RED)&lt;/code&gt; will draw a circle.



== Detailed documentation ==

Note. all co-ordinates are from the top left (battery symbol) corner. All widgets are created from the "ugfx" package, eg: ugfx.Contailer().

=== Colour format ===

Internally, ugfx uses 565 format (5 bits for red and blue, 6 for green). Preset colours are available, for example '''ugfx.RED''', '''ugfx.ORANGE''', etc. To convert from 24 bit RGB format, use '''ugfx.html_color(0xRRGGBB)''' to return the 16 bit 565 format.

=== Styles and Fonts ===
Use &lt;code&gt;ugfx.set_default_font(...)&lt;/code&gt; to change the font. The font options are:
* ''ugfx.FONT_SMALL''
* ''ugfx.FONT_MEDIUM''
* ''ugfx.FONT_MEDIUM_BOLD''
* ''ugfx.FONT_TITLE''
* ''ugfx.FONT_NAME''.
Note that widgets use the font which was default when they were created, while the ''container.text()'' primitive uses the font that was default when the container was created

=== Containers ===

    .Container(x, y, width, height {,style})  # the style is optional

Containers can be used to group widgets together. They can also perform primitive drawing functions. When drawing widgets or primitives, the coordinates are relative to the top left corner of the container.

Containers can be shown or hidden, and all the widgets will be redrawn (primitives are not widgets and are not redrawn). Containers can also be placed on top of other widgets. When the top container is hidden, the widgets below will be redrawn.

Upon creation a style can be passed to a container, which will then be used by default by widgets created as part of that container. If no style is specified at creation, the current default style will be used.

The following example shows  how to create a container, add an object and show it.
&lt;pre&gt;
c = ugfx.Container(100,100,200,100)
b = ugfx.Button(10, 10, 40, 30, "OK", parent=c)
c.show()            # the container will not be shown until this point
c.fill_circle(5,5,5,ugfx.RED) #draws a small red circle. Note this has to be done after .show()
&lt;/pre&gt;

=== Primitives ===
All primitives can be drawn anywhere on the screen with, for example &lt;code&gt;ugfx.circle(..)&lt;/code&gt;, or anywhere within a container, with &lt;code&gt;c=ugfx.Container(30,30,100,100); c.circle(..)&lt;/code&gt;

Note: The container must be shown ''before'' you can draw primitives in it. When hiding the container, all drawings are lost!

==== Clear ====

&lt;code&gt;.clear(colour = ugfx.WHITE)&lt;/code&gt;

clears the screen to the specified colour. Warning, this is slow!

==== Lines ====
&lt;code&gt;.line(&lt;x1&gt;, &lt;y1&gt;, &lt;x2&gt;, &lt;y2&gt;, &lt;colour&gt;)&lt;/code&gt;

&lt;code&gt;.thickline(&lt;x1&gt;, &lt;y1&gt;, &lt;x2&gt;, &lt;y2&gt;, &lt;colour&gt;, &lt;width&gt;, &lt;round&gt;)&lt;/code&gt;

Draws a line from ''x1,y1'' to ''x2,y2'' using ''colour''. Thickline will draw a line or arbitrary width, with the option of rounded corners

eg. ''ugfx.thickline(0,0,100,170,ugfx.YELLOW,7,0)''

==== Circle ====
&lt;code&gt;.circle(x, y, radius, colour)&lt;/code&gt;

&lt;code&gt;.fill_circle(x, y, radius, colour)&lt;/code&gt;

Draws a circle at ''x,y'' of &lt;radius&gt; using ''colour'', either with a 1 pixel border or filling the area.

eg. ''ugfx.circle(180,150,40,ugfx.RED)''

==== Arc ====
&lt;code&gt;.arc(x, y, r, angle1, angle2, colour)&lt;/code&gt;

&lt;code&gt;.fill_arc(x, y, r, angle1, angle2, colour)&lt;/code&gt;

Similar to the circle functions, however two angle parameters specify between which two angles drawing occurs

==== Ellipse ====
&lt;code&gt;.ellipse(x, y, a, b, colour)&lt;/code&gt;

&lt;code&gt;.fill_ellipse(x, y, a, b, colour)&lt;/code&gt;

Draws an ellipse at ''x,y'' of ''a'' width and ''b'' height using ''colour'', either with a 1 pixel border or filling the area.

==== Rectangles ====
&lt;code&gt; .box(1, y, a, b, colour) &lt;/code&gt;

&lt;code&gt; .area(x, y, a, b, colour)&lt;/code&gt;

Draws a rectangle or filled rectangle at ''x,y'' of ''a'' width and ''b'' height using ''colour''.

==== Polygon ====
&lt;code&gt; .polygon(x, y, array, colour) &lt;/code&gt;

&lt;code&gt; .fill_polygon(x, y, array, colour) &lt;/code&gt;

Draws or fills a polygon starting at ''x,y'' using ''colour''. ''Array'' is an array of coordinates that specifies the corners.

eg. ''ugfx.polygon(0,0, [ [0,20],[20,20],[20,0]], ugfx.RED)''

==== Text ====
&lt;code&gt;.text(x, y, text, colour) &lt;/code&gt;

Draws a text string ''text'' at ''x,y'' in ''colour''.
Note that a ugfx.text(..) call will take the default font, while container.text(..) will take the containers font.

eg. ''ugfx.text(40,40,"My name is...",ugfx.BLUE)''

==== Other ====
&lt;code&gt;.width()&lt;/code&gt;

&lt;code&gt;.height()&lt;/code&gt;

Gets the height or width of the screen ''ugfx.width()'' or container object ''c.width()''

=== Widgets ===

Widgets can be drawn anywhere on the screen, or within a container. The widgets take the optional parameter ''parent='' to set the parent container. Widgets can have their style set on creation, otherwise will inherit 

Widgets also accept input from the buttons. For example, the 'A' button can be 'attached' to an on-screen button, such that pressing the button on the badge causes the on-screen button to be redrawn in a depressed state. 

==== Common Widget methods ====

&lt;code&gt;.text([text])&lt;/code&gt;

Gets or sets the text displayed by the widget.

&lt;code&gt;.visible([show])&lt;/code&gt;

Gets or sets the visibility of the badge. ''b.visible(0)'' will hide, and ''b.visible(1)'' will show.

&lt;code&gt;.attach_input(button, function)&lt;/code&gt;

Attaches a physical button to a widget, so that the user can cause the widget to redraw, for example to scroll or become depressed.

The input ''button'' specifies which button, with the options ugfx.BTN_A, ugfx.BTN_B, ugfx.BTN_MENU, ugfx.JOY_UP, ugfx.JOY_DOWN, ugfx.JOY_LEFT, ugfx.JOY_RIGHT.

The input ''function'' specifies what the button actually does. For example, the list has three different functions: scroll up, scroll down, and select. Note that some widgets by default attach the joystick to the relevant functions. 

&lt;code&gt;.detach_input(function)&lt;/code&gt;

Detaches an input. See above for more details.

&lt;code&gt;.destroy()&lt;/code&gt;

Frees up all the resources assoicated with the object. While the micropython garbage collector will clear any old objects, the graphics library also has its own memory area, which can become full if objects are not destroyed after they are needed.

&lt;code&gt;.set_focus()&lt;/code&gt;

Gives focus to the widget instance. Normally this will draw a box around the widget, the colour is specified by the style.

==== Button ==== 

&lt;code&gt; b=ugfx.Button(x, y, w, h, text, *, parent=None, trigger=None, shape=ugfx.Button.RECT, style=None) &lt;/code&gt; (note: parameters after '*' are optional)

Draws a button at ''x,y'' having width ''a'' and height ''b''. The option 'trigger' specifics which physical switch (if any) causes the display to be redrawn. The shape options are ''ugfx.Button.RECT'', ''ugfx.Button.ROUNDED'', ''ugfx.Button.ELLIPSE'', ''ugfx.Button.ARROW_UP'', ''ugfx.Button.ARROW_DOWN'', ''ugfx.Button.ARROW_LEFT', ''ugfx.Button.ARROW_RIGHT''.

==== Textbox ====
&lt;code&gt; ugfx.Textbox(x, y, w, h, *, text=None, parent=None, maxlen=255})&lt;/code&gt;

Draws a text edit-box which can take input from the on-screen keyboard. Will automatically accept key-presses from the keyboard, which will edit the text. The textbox needs to have focus using .set_focus() for it to receive the key-presses.

==== Checkbox ====

&lt;code&gt;.Checkbox((x, y, w, h, text=None, parent=None, trigger=None, style=None)&lt;/code&gt;

&lt;code&gt;.checked()&lt;/code&gt;

Get or set the checked state


==== Label ====

&lt;code&gt; ugfx.Label(x, y, w, h, text, *, parent=None, style=None, justification=None)&lt;/code&gt;

A label displays text. Unlike the primitive text, this Label supports different justifications, wordwrap and changing text. The different justification options are ''ugfx.Label.LEFT'', ''ugfx.Label.RIGHT'', ''ugfx.Label.CENTER'', ''ugfx.Label.LEFTTOP'', ''ugfx.Label.RIGHTTOP'' and ''ugfx.Label.CENTERTOP''.

==== List ====

&lt;code&gt;ugfx.List(x, y, w, h, *, parent=None, up=ugfx.JOY_UP, down=ugfx.JOY_DOWN, style=None)&lt;/code&gt;

&lt;code&gt;.enable_draw()&lt;/code&gt;

&lt;code&gt;.disable_draw()&lt;/code&gt;

&lt;code&gt;.add_item(text)&lt;/code&gt;

&lt;code&gt;.assign_image(index, image)&lt;/code&gt;

&lt;code&gt;.remove_item(index)&lt;/code&gt;

&lt;code&gt;.selected_text()&lt;/code&gt;

&lt;code&gt;.selected_index()&lt;/code&gt;

&lt;code&gt;.count()&lt;/code&gt;

==== Graph ====

&lt;code&gt;ugfx.Graph(x, y, w, h, origin_x, origin_y)&lt;/code&gt;

&lt;code&gt;.show()&lt;/code&gt;

&lt;code&gt;.hide()&lt;/code&gt;

&lt;code&gt;.set_arrows(ugfx.Graph.ARROWS_X_POS | ugfx.Graph.ARROWS_Y_POS)&lt;/code&gt;

Set which axes have arrows and in which direction. In this example arrows are set for the x and y positive directions, with the following options available: ARROWS_X_POS, ARROWS_Y_POS, ARROWS_X_NEG, ARROWS_Y_NEG


&lt;code&gt;.plot( point(s)_x, point(s)_y, {new_series} )&lt;/code&gt;

Plot either an array, or a point. Optional second parameter specifies whether to start a new series or join onto previous.


&lt;code&gt;.appearance( thing_to_change, shape, size, colour, {spacing}  )&lt;/code&gt;

Changes the style of either points, lines, axis or grids. Each parameter is used as follows:

'thing_to_change' - select what aspect to change, the options are {STYLE_POINT, STYLE_LINE, STYLE_XAXIS, STYLE_YAXIS, STYLE_XGRID, STYLE_YGRID}

'shape' - selects the shape of the thing to change, where the options depend on what you are changing.
The options for points is: {POINT_NONE, POINT_DOT, POINT_SQUARE, POINT_CIRCLE}
The options for line/axis/grid are: {LINE_NONE, LINE_SOLID, LINE_DOT, LINE_DASH}

'size' - number of pixels wide of the thing to change

'colour' - use UGFX.Red, UGFX.Orange,...  or UGFX.html_color(0xRRGGBB) to ensure the right format

'spacing' - only valid for grid

See the [https://github.com/emfcamp/Mk3-Firmware/blob/master/apps/logger/main.py BARMS logger app] for an example

==== Imagebox ====

&lt;code&gt;.Imagebox(x, y, w, h, filename, *, cache=0, parent=None, style=None)&lt;/code&gt;

This displays an image box. This will automatically animate a passed gif

==== Keyboard ====

&lt;code&gt;.Keyboard(x, y, w, h, parent=None)&lt;/code&gt;

=== Styles ===
&lt;pre&gt;
s=ugfx.Style()  # create a style based on the current default style

s.set_enabled([text_colour, edge_colour, fill_colour, progress_colour]) # sets the style for when something is enabled
s.set_pressed([text_colour, edge_colour, fill_colour, progress_colour]) # sets the style for when something is pressed
s.set_disabled([text_colour, edge_colour, fill_colour, progress_colour]) # sets the style for when something is disabled

s.set_focus(colour)  # sets the colour used for focus
s.set_background(colour) # sets the background colour for the style

ugfx.set_default_style(s) # use this style from now on

b=ugfx.Button(0,0,40,30,"OK", style=s) # use the style for this button

&lt;/pre&gt;

== Tips and tricks ==

=== Tearing ===

When writing large areas of the screen, a 'tearing' [https://en.wikipedia.org/wiki/Screen_tearing] effect may be observed.

The screen module is comprised of a large memory, with one memory location to store the RGB data for each pixel. The LCD driver continuously updates the LCD pixels, by reading the memory in a sequential, line-by-line manner, and updating the LCD with the data from the memory. This 'read line-pointer' moves from the top to the bottom of the screen (when viewed in portrait), at about 70Hz (the refresh rate of the screen)

This large memory as part of the screen means it can be driven by a microcontroller which may have a considerably smaller memory. The microcontroller therefore only needs to update the memory when it whats the content to change. 

Consider the scenario where the microcontroller wants to set the screen from one colour to another. The microcontroller needs to update the entire memory (320x240x2 = 153kB) with the new colour. At the same time the 'read line-pointer' is reading the same memory to update the LCD. In this case, tearing occurs if the 'read line-pointer' reads the top half of the memory containing the new colour, but then catches up with microcontroller writing to the memory, then the 'read line-pointer' starts reading the old colour in the bottom half of the memory.

To avoid tearing the 'read line-pointer' should not cross the region the microcontroller is updating. Since the microcontroller writes to the screen slightly slower than the LCD reads it, providing the microntroller starts writes to the top of the memory just after the LCD starts reading from the top, the read and write pointers will not overlap, and tearing will not occur. To sync the microcontroller with the LCD 'read line-pointer,' there is a vsync/tear output (connected to pin named 'TEAR') which is pulled high when the 'read line-pointer' reaches a given line (default is line 0). This can be turned on and off with '''ugfx.enable_tear()''' and '''ugfx.disable_tear()'''. To change the line at which the tear output is generated, use '''ugfx.set_tear_line(0..319)'''.

Example code:

    ugfx.enable_tear()
    tear = pyb.Pin("TEAR", pyb.Pin.IN)
    
    def vsync():
        while tear.value() == 0:
            pass
        while tear.value():
            pass

=== Reducing power consumption ===
Use the following to dim the backlight, which uses about 80mA at full brightness
&lt;pre&gt;
ugfx.backlight(b)     # sets the backlight. Range is 0-100
b = ugfx.backlight()   # reads the current backlight
&lt;/pre&gt;

== Top-Level calls ==

&lt;code&gt;.power_mode(&lt;mode&gt;)&lt;/code&gt;

''mode'' can be any of: ugfx.POWER_ON, ugfx.POWER_OFF, ugfx.POWER_DEEP_SLEEP, ugfx.POWER_SLEEP

&lt;code&gt;.orientation(deg)&lt;/code&gt;

Rotate the display by number of degrees, eg 180 for upside-down.

Calling with no args returns the current value

&lt;code&gt;.display_image(x, y, '/path/to/image', orientation)&lt;/code&gt;
&lt;code&gt;.display_image(x, y, img_obj, orientation)&lt;/code&gt;

Display an image from a file of a supported type, or a previously opened image object, on screen at the x,y co-ordinates. Optionally change its orientation.

&lt;code&gt;.write_command(0x35,0)&lt;/code&gt;

Low-level command to write to a data register directly.

&lt;code&gt;.poll()&lt;/code&gt;

Yield to ensure the screen is redrawn when waiting on user input

&lt;code&gt;.ball_demo()&lt;/code&gt;

Ball Demo!

&lt;code&gt;.get_pixel(x, y)&lt;/code&gt;

Returns the colour of the pixel at x,y

&lt;code&gt;.Image(filename, cacheme)&lt;/code&gt;

Creates and returns (or loads from cache) a ugfx image object from the image in the filename.</text>
      <sha1>029irwzclpoggzps28wnci2t1qryjio</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MKe</title>
    <ns>0</ns>
    <id>3</id>
    <revision>
      <id>466</id>
      <parentid>465</parentid>
      <timestamp>2021-05-26T08:18:09Z</timestamp>
      <contributor>
        <username>Thinkl33t</username>
        <id>2</id>
      </contributor>
      <origin>466</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9832" sha1="p0lbsn53ui47gyfv1kiyi6mtemcalac" xml:space="preserve">[[File:IMG_0474.jpg|500px|right|thumb|Front]]
[[File:Badge_Front.png|right|thumb|Front]]

[http://en.wikipedia.org/wiki/E_(mathematical_constant) Why MKe?]

=EMF 2014 Badge= 
The main aim of the 2014 badge is to give camp attendees an interesting bit of hardware to play with during the camp and experiment with afterwards. We designed an Arduino compatible platform to allow easy reuse and access, and have published all code and design files.

[http://blog.emfcamp.org/post/94157161753/announcing-tilda-mke-the-incredible-emf-2014-camp Blog post launching the badge]

==Battery Warning==
A very last minute battery (and connector) change on the badge due to a supplier problem meant two issues arose with the badge during EMF:

* '''Always make sure to plug your battery in the right way round!''' The new battery connector allows you to connect it backwards. We did our best to mitigate this, but connecting it incorrectly will destroy the power management controller and prevent the badge from charging or running from the battery. It will still function perfectly using USB power. "Red" and "Black" are written next to the connector - please make sure to plug it in correctly.

* '''Be careful not to short the battery connector wires!''' The new battery connector slightly exposes the wires when the battery is plugged in. If a metal object shorts the two wires, it can result in extreme battery damage. If we'd known this was such an issue before the event we would have applied protective material to it - we suggest covering the exposed connector in tape, sugru, blu-tack, or some other insulating material. Alternatively, simply unplug the battery when your badge is not in use!

==My badge is broken!==
Due to the aforementioned supplier issues it is possible that you may have received a faulty badge, or it may have been damaged by connecting the battery backwards. If you badge will not turn on when it has been plugged in with a MicroUSB cable (and the power switch on the back is set to "USB"), or something else seems wrong with it, please email [mailto:badge@emfcamp.org badge@emfcamp.org] and we'll try to fix or replace your badge.

=The Hardware=
The badge has a plethora of hardware built in for you to play with, everything from accelerometers and gyroscopes to hidden ethernet headers! Breaking it all down is too much detail for this document, however we'll call out some things we built in that you might want to play with.

Remember the badge is Arduino Due compatible, and we broke out nearly all the features of the ARM chip so you can access them. [http://arduino.cc/en/Main/ArduinoBoardDue Anything the Due can do], the TiLDA can do!

==Interesting things to play with==
Most of the interesting things are on the back of the badge. They're clearly marked in white. [https://wiki.emfcamp.org/w/images/b/bd/Badge_Back.png This diagram of the back] should allow you to locate them. Some of the following require extra parts to be added to your badge.

* Full Arduino R3 shield compatible pins (Requires soldering the headers on the back of the badge)
* Pins either side of the lanyard holes for conductive thread (D19, D18, GND, 3V3)
* Infrared transmitter on the front (Pin shortcut IR_TX_PWM)
* Infrared receiver on the front (Pin shortcut IR_RX, Part Vishay TSOP75238TT available from digikey and Farnell )
* Piezo buzzer (Pin shortcut PIEZO or PIEZO_PWM)
* On-board ethernet (not available on the Due) - requires breakout module (eBay: Elechouse Taijiuino Ethernet PHY DM9161 Module)
* [http://www.invensense.com/mems/gyro/mpu6050.html MPU-6050] 3-axis Accelerometer and 3-axis gyro (IMUTask.cpp and the MPU6050 library)
* 128x64 pixel backlit LCD display (JHD12864, see [https://github.com/emfcamp/Mk2-Documentation/tree/master/LCD%20JHD12864 here for docs])
* [http://shop.ciseco.co.uk/srf-wireless-rf-radio-surface-mount/ Ciseco SRF Radio]
* 1 megabit flash module (Part S25FL216K0PMFI011)
* 2x RGB LEDs on the front 

Some features are not mentioned here, or optional extras.  They can be found in the [[TiLDA_MKe/Full_Specification]]

=The Software=

==Basic post-event features==
We made sure that the badge has a few features to play with once the event is over. More will be added over time as attendees submit changes to us.

[[File:Badge_Back.png|right|thumb|Back]]
* Torch mode - Press the light button next to the screen. It will only light up fully if it's hung upside down to avoid blinding
* Snake
* Tetris

But of course the point of the badge is to modify it and use it for other interesting things! The following sections describe how to update the firmware on the badge, how to use it as a simple arduino, and how to write your own code for the main badge firmware.

==Getting help==
The EMF 2014 badge is a complex piece of hardware and software, however remember that you can just treat it as an Arduino if you find it all too daunting.

If you get stuck and need advice, join us in #emfcamp-badge on [https://libera.chat/ Libera IRC] to ask for advice, or if you're really stuck you can email us on [mailto:badge@emfcamp.org badge@emfcamp.org].

==How to update the badge software==
The badge software has been substantially updated since EMF, fixing bugs and removing features that will no longer work now you're away from our radio network. You should update your badge before starting to play with it any further. If you've never used an Arduino before this might be tricky - ask an Arduino-literate friend to help you, or drop by your nearest [http://hackspace.org.uk hackspace] and ask for advice.

The badge is Arduino Due compatible, so [http://arduino.cc/en/Guide/ArduinoDue some of their instructions may help you if you have problems].

===Set up your environment===
* Plug your badge into your computer via a MicroUSB cable. Make sure the power switch on the back is set to "USB".
* Download the newest version of the Arduino IDE from http://arduino.cc/en/main/software
* Download the TiLDA firmware code from https://github.com/emfcamp/Mk2-Firmware
* Start the Arduino IDE.
* Now you have to change the sketchbook-folder to be the folder you just cloned or downloaded. To do this use File -&gt; Preferences -&gt; ‚ÄúSet Sketchbook location‚Äù. On MacOS, this is Arduino -&gt; Preferences. 
* Restart the Arduino IDE.
* Open sketch ‚ÄúEMF2014‚Äù.
* Set Tools -&gt; Board to MKe v0.333 (RTOS Core).
* Set Tools -&gt; Port to correct port for the Arduino
** On MacOS this is will start /dev/tty.usbmodem with 4 digits, and change for each port
** On Linux this is usually /dev/ttyACM0 but may be a higher number if you have other USB Serial devices
* Hit the upload button
* Wait
* Your badge should now be running the latest TiLDA firmware!

==Programming the badge as an Arduino==
The badge is completely Arduino Due compatible, simply set the board type to "MKe v0.333(Arduino Core)" upload normal Arduino code and the badge will function.

If you program the badge with simple Arduino code, you can always revert to the official firmware. Simply change the sketch to "EMF2014", and set the board type to "MKe v0.333 (RTOS Core)") and upload.

===blink.ino===
Here is a tweaked version of the standard blink sketch that will flash the RX and TX LEDs

&lt;pre&gt;
  void setup() {
    pinMode(PIN_LED_TX, OUTPUT);
    pinMode(PIN_LED_RX, OUTPUT);
  }
  
  void loop() {
      digitalWrite(PIN_LED_TX, HIGH);
      digitalWrite(PIN_LED_RX, LOW);
      delay(1000);
      digitalWrite(PIN_LED_TX, LOW);
      digitalWrite(PIN_LED_RX, HIGH);
      delay(1000);
  }
&lt;/pre&gt;

#TODO ADD LINK TO PIN MAPPING NAMES/DEFINITIONS

===Writing to the Screen===
#TODO

===Reading from the Accelerometer===
#TODO

===Reading the Battery Voltage===
#TODO

===Controlling the LEDs===
#TODO

===Reading Button &amp; Joystick Input===
#TODO

===Buzzer?===
#TODO

===Using the Radio to Send and Receive Data===
#TODO

===Arduino Gotchas===
* Most Arduino code out there use Serial not SerialUSB. On MKe Serial is wired to the SRF radio. When using example code do a find and replace for Serial/SerialUSB this will redirect the Serial traffic of the USB port
* If you want to send data over the Radio you need to wake it and enable it first, set SRF_SLEEP to LOW using the following two lines of code  &lt;code&gt;pinMode(SRF_SLEEP, OUTPUT); digitalWrite(SRF_SLEEP, LOW);&lt;/code&gt;

==Programming the badge in FreeRTOS==
[[TiLDA_MKe/FreeRTOS|See this page for information on howto program your badge using FreeRTOS]]

==Contribute==
Send us a pull request via [https://github.com/emfcamp/Mk2-Firmware GitHub] - We‚Äôll do our best to review and merge the good ones so others can use them.

=Cool Hacks!=
==3d printable &amp; laser-cuttable badge case==
3d print-able and laser-able case files [http://www.thingiverse.com/thing:436815 here]

==Making the badge Arduino shield compatible==
[[File:Sheild_Headers.JPG|500px|right|thumb|Sheild Headers]]
To make the badge Arduino shield compatible you'll need to solder simple strips of header pins onto the back of the badge. 
You need the following headers
{| class="wikitable"
|-
! Qty !! Type !! Use !! Rapid part
|-
| 1 || 2x03 Male || SPI ||
|-
| 2 || 1x08 Female || Power, Analog pins ||
|-
| 2 || 1x10 Female || Digital pins ||
|-
| 1 || 2x08 Male || Ethernet ||
|}
The picture to the right shows the placement.

= Source =

All the source code and designs are on openly available on Github:

* [https://github.com/emfcamp/Mk2-Hardware Hardware] - the full board design
* [https://github.com/emfcamp/Mk2-Documentation Documentation] - a dump of relevant parts datasheets
* [https://github.com/emfcamp/Mk2-Firmware Firmware] - source code for the badge software
* [https://github.com/emfcamp/Mk2-Software Software] - server-side software for the network

If you want to help, point your IRC client to #emfcamp-badge on [https://libera.chat/ Libera IRC].

[[Category: Badges]]</text>
      <sha1>p0lbsn53ui47gyfv1kiyi6mtemcalac</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MKe/FreeRTOS</title>
    <ns>0</ns>
    <id>8</id>
    <revision>
      <id>17</id>
      <timestamp>2015-05-01T15:54:34Z</timestamp>
      <contributor>
        <username>Thinkl33t</username>
        <id>2</id>
      </contributor>
      <comment>Created page with "=Programming the badge in FreeRTOS= ==Your first ‚ÄúHello world‚Äù app== There‚Äôs a ‚ÄúHelloWorldApp.cpp‚Äù file in which you can play around. In order for it to show up on t..."</comment>
      <origin>17</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="14139" sha1="5xfqayqqs3c78vps545ab4o0lyu40rv" xml:space="preserve">=Programming the badge in FreeRTOS=
==Your first ‚ÄúHello world‚Äù app==
There‚Äôs a ‚ÄúHelloWorldApp.cpp‚Äù file in which you can play around. In order for it to show up on the Homescreen you have to uncomment line 51 in AppManager.cpp and flash the changed code to the badge. Great app pull requests are appreciated!

If you are still using the Arduino IDE at this point, note that it will not let you edit the .cpp and .h files that are needed to create Apps for the badge. To force the IDE to re-compile/re-read any files you've edited using an external editor, make sure to go to the File -&gt; Preferences dialog box, and check the "Use external editor" checkbox.

==Why are things so different from standard Arduino code?==
We‚Äôre using a library called FreeRTOS that allows us to multitask - something that‚Äôs normally not possible with standard Arduino code. This allows us to run multiple tasks at the same time. FreeRTOS uses preemptive scheduling to switch between the task. Due to this we have to be very careful about how we do some things. For example we can‚Äôt just define interrupts for buttons in every task (imagine the mess!) or write to the serial port directly (your task might stop in the middle of the message). 

We‚Äôve also spent quite a lot of time to make the built-in components as easy to use as possible without having every task to write lots of boilerplate code. If you feel like using the build-in components on the badge, chances are we already wrote a wrapper for them that is already used by one of the other tasks. 

Have a look at the ‚ÄúDocumentation‚Äù section in this document for a full list of API functions. You will avoid a lot of headaches if you stick to those.

== Code structure ==
* FreeRTOS has the concept of ‚ÄúTasks‚Äù which work like threads. We‚Äôve wrappered them in a class called ‚ÄúTask‚Äù (for background stuff) and ‚ÄúApps‚Äù (for foreground, one-at-a-time things)
* Everything needs to be in the main EMF2014 folder. Subfolders are not allowed. This is an Arduino IDE restriction :(

==Debugging and Gotchas==
* The USB serial is set up to 115200 baud. There are lots of terminals that can connect to them. See below for how to enable the debug logging.
* If you can‚Äôt revive a badge, or only get the two red programming LEDs when you plug it, in, do a full erase (see below)
* Avoid busy waiting, use FreeRTOS queues and Tilda::delay() instead
* Don‚Äôt use low level functions like interrupts or serial ports directly unless you really, really know how FreeRTOS will handle them. For general logging you can use Tilda::log()
* If sending code to the badge using the Arduino IDE "Upload" button fails, even though the /dev/ttyACM0 (linux com port) is there, just retry, twice if neccessary.

==Full erase==
This is the failsafe process if your badge won't show up over USB.

# Unplug the badge
# Connect the Erase pins on the back together (two holes down the left hand side next to the battery and under the blue wireless module). You can use a jumper, jump wire, or the leg of a resistor for this.
# Turn the badge back on with the switch or plug it back in
# Press the Reset button on the front (bottom centre) and release
# Wait 15 seconds
# Unplug the badge or turn it off

When you plug the badge back into a computer it will come back up in programming mode, with a different serial port to the usual one. Open the EMF 2014 sketch in the Arduino IDE, select the Tilda v0.333 (RTOS) programmer, and find the new serial port. The IDE console should show something like this:

 Sketch uses 118,748 bytes (22%) of program storage space. Maximum is 524,288 bytes.
 Erase flash
 Write 127668 bytes to flash
 
 [                              ] 0% (0/499 pages)
 [                              ] 2% (10/499 pages)
 [=                             ] 4% (20/499 pages)
 [=                             ] 6% (30/499 pages)
 ...
 [============================= ] 98% (490/499 pages)
 [==============================] 100% (499/499 pages)
 Verify 127668 bytes of flash
 
 [                              ] 0% (0/499 pages)
 [                              ] 2% (10/499 pages)
 [=                             ] 4% (20/499 pages)
 [=                             ] 6% (30/499 pages)
 ...
 [============================= ] 98% (490/499 pages)
 [==============================] 100% (499/499 pages)
 Verify successful
 Set boot flash true
 CPU reset.



=Useful Hacks &amp; Non-Programming Information=

==Your own wireless badge network==
[[DIY TiLDA Badge Network]] has instructions on how to setup your own private badge network using a RaspberryPi and two Ciseco radios.

==Convert images to TiLDA bitmap format==
* A Python script (via [https://twitter.com/trotmaster99 @trotmaster99]) that converts a monochrome bitmap image into a format suitable for the Tilda can be found [http://pastebin.com/8XeazQjT here].
* A similar script in Perl to create TiLDA MKe fullscreen bitmaps from XBM: -
&lt;div style ="height:200px;overflow-x:hidden;overflow-y:auto;border: 4px solid orange;"&gt;
'''xbm2mke.pl by [[User:Msemtd]]'''
 &lt;nowiki&gt;
#!perl -w
use strict;
# Little script to convert a regular XBM to TiLDA MKe bitmap
# only tested with fullscreen bitmaps!
# Hot file handle magic...
select((select(STDERR), $| = 1)[0]);
select((select(STDOUT), $| = 1)[0]);
sub t(@);
sub d($);
sub chug($);
my $f = shift;
#~ $f = 'blankish.xbm' if not $f;
if(not defined $f or not $f =~ /^(.*)\.xbm$/i){
    die "Usage: gimme an XBM file dude!\n";
}
my $name = $1;
t "Reading file '$f'...";
my $data = chug($f);
t "OK";
my @lines = split /^/, $data;
@lines = grep{chomp; s/^\s+//; s/\s+$//; length;} @lines;
#~ t d \@lines;
my($width, $height) = (0,0);
my @head = @lines[0..5];
foreach(@head){
    if(/_width\s+(\d+)/){$width = $1;}
    if(/_height\s+(\d+)/){$height = $1;}
}
t "width x height = $width x $height";
my @k;
foreach(@lines){ push @k, split /,/; }
@k = grep { s/^.*(0x[0-9A-Fa-f]{1,2}).*$/$1/o; /(0x[0-9A-Fa-f]{1,2})/o } @k;
#~ t d \@k;
my $bc = scalar(@k);
t "Pulled out $bc hex bytes";
if($bc != $width * $height / 8) {
    die "byte count $bc does not match that expected for w x h";
}
t "OK - reorder bytes for MKe bitmap";
my $wb = int($width/8) + (($width &amp; 0x07) ? 1: 0);
t "width in whole bytes for $width pixels = $wb";
my @mke;
for(my $col = 0; $col &lt; $wb; $col++){
    for(my $row = $height - 1; $row &gt;= 0; $row--){
        my $idx = ($row * $wb) + $col;
        my $val = $k[$idx];
        #~ t "Column $col + Row $row = idx $idx = $val";
        push @mke, $val;
    }
}
my $out = "static const uint8_t ".uc($name)."_BM[] = {\n"
	."    $width, // width\n"
	."    $height , // height\n";
#~ $out .= join(", ", @mke);
while(scalar @mke){
	$out .= join(", ", splice(@mke, 0, 16)).",\n";
}
$out .= "};\n";
# meh, just print it out
t $out;

sub t(@) {
    foreach (@_) {
       print STDOUT "$_\n";
    }
}
sub d($) {
    require Data::Dumper;
    my $s = $_[0];
    my $d = Data::Dumper::Dumper($s);
    $d =~ s/^\$VAR1 =\s*//;
    $d =~ s/;$//;
    chomp $d;
    return $d;
}
sub chug($) {
  my $filename = shift;
  local *F;
  open F, "&lt; $filename" or die "Couldn't open `$filename': $!";
  local $/ = undef;
  return &lt;F&gt;;
}  # F automatically closed

&lt;/nowiki&gt;
&lt;/div&gt;
 
= Firmware Documentation =
== Debugging ==
===Enabling the USB serial debug log messages===
To enable the debug logging you must uncomment the following line in [https://github.com/emfcamp/Mk2-Firmware/blob/master/hardware/emfcamp/sam/libraries/debug/debug.h#L42 hardware/emfcamp/sam/libraries/debug/debug.h]

 // Enable debug task and output
 // #define DEBUG 1

===Tilda::log(String text)===

This logs ‚Äútext‚Äù to the serial console. To read it connect to it via the Arduino IDE Serial Monitor. Don‚Äôt use ‚ÄúSerialUSB.println‚Äù or similar -- it‚Äôs not thread-safe and you might end up with utter nonsense.

===Debugging using the JTAG interface===
The JTAG interface on the board provides powerful debugging facilities like breakpoints, backtraces, dumping memory, inspecting variables, checking task states, catching exeptions etc. To make this to work requires additional hardware and software, see [[TiLDA Debugging using JTAG]].

== Buttons ==
The badge has 8 buttons: Up, Down, Left, Right, Center (on the joystick), A, B and Light. You can use arduino-style ‚ÄúdigitalRead(BUTTON_RIGHT)‚Äù to read the current status of any button, but you can‚Äôt define your own interrupt (because we already did that). This doesn‚Äôt mean you can‚Äôt wait for a certain button to be pressed, it just means you have to approach it slightly differently:

Example: A simple app displaying the button code
 void ButtonApp::task() {
     ButtonSubscription allButtons = Tilda::createButtonSubscription(LIGHT | A | B | UP | DOWN | LEFT | RIGHT | CENTER);
 
     while(true) {
         Button button = allButtons.waitForPress(1000);
         if (button == A) {
             debug::log(‚ÄúYou pressed button A‚Äù);
         } else if (button == LEFT) {
             debug::log(‚ÄúYou pressed LEFT‚Äù);
         } else if (button == NONE) {
             debug::log(‚ÄúNo button has been pressed in 1000ms‚Äù); 
         }
     }
 }


===ButtonSubscription Tilda::createButtonSubscription(&lt;buttons&gt;)===

Registers a subscriptions for a defined set of buttons and returns a ButtonSubscription. Multiple Buttons can be combined via ‚Äú|‚Äù (see example above). One button can not be subscribed by more than 10 subscriptions (which shouldn‚Äôt really happen, but keep it in mind). 

Don‚Äôt use this function in a constructor, it requires FreeRTOS to be running. Using it inside the task() function is the only safe place for it.

===Button ButtonSubscription::waitForPress(TimeInTicks timeout)===

This is normally called in a loop. It causes the task to block until one of the buttons has been pressed. If the timeout occurs before any button has been pressed ‚ÄúNONE‚Äù will be returned. 

===ButtonSubscription::waitForPress()===

The same as above, but without the timeout.

===ButtonSubscription::clear()===

This should be called after an App has been suspended, just before it‚Äôs going to be resumed. It causes the Queue to be cleared which could otherwise lead to buttons being reported that have been pressed while other apps were in the foreground. Have a look at the FlashLightApp for an example.

==LEDs==
===Tilda::setLedColor(Led led, Color color);===
===Tilde::setLedColor(Color color);===

Sets the color of all or one led. Color is an object that takes red, green and blue as a value between 0 and 255 each. If no led is defined both leds will be set to the same color.

Example: A simple color-changing task
 void ColorfulTask::task() {
     while(true) {
         Tilda::setLedColor(LED1, {255, 0, 0}); // Red
         Tilda::setLedColor(LED2, {0, 255, 0}); // Green
         Tilda::delay(300);
         Tilda::setLedColor(LED1, {0, 255, 0}); // Green
         Tilda::setLedColor(LED2, {0, 0, 255}); // Blue
         Tilda::delay(300);
         Tilda::setLedColor(LED1, {0, 0, 255}); // Blue
         Tilda::setLedColor(LED2, {255, 0, 0}); // Red
         Tilda::delay(300);
     }
 }

==Display==

The Display Library is based on GLCDv3 (http://playground.arduino.cc/Code/GLCDks0108), docs (http://code.google.com/p/glcd-arduino/source/browse/trunk/glcd/doc/GLCD_Documentation.pdf) but adapted to support our screen.  The Init routine is called in the setup, and the LCDTask takes care of ensuring the screen is updated every 40ms if required (Unlike the original GLCD library, screen updates are decoupled from the graphics routines.)

Also available is M2tklib (https://code.google.com/p/m2tklib/) which is a nice toolkit library.  Further details on using this will come later, but expect the main loop to be handled for you, and just passing the menu structure you require for your app.

Right now, you can call the GLCD functions directly with GLCD.DrawBitmap() for example.  This is going to change to be accessed through the GUITask class in the near future, to ensure only one task at a time writes to the screen.  Expect this to be simply GUITask in place of GLCD, along with a registering a redraw call back to GUITask. The bitmap format, by the way, is rather unconventional but there are a couple of utility scripts to convert popular formats down in the hacking section below - you can grab the SponsorsApp.h as an example and swap out the bitmap array with one of your choosing.

Extra features that are included, GLCD.SetRotation() will handle rotation of the screen for you, and GLCD.CurrentWidth() and GLCD.CurrentHeight will give you the correct Width and Height for the current orientation.  GLCD.Width and GLCD.Height constants are not available, and the GLCD predefined Text areas will not be rotated for you, if you require this define your own text areas.

Note that one function was not ported to the badge version of GLCD, "Printf", you'll have to cope without it.

== Sound == 
There's a fully working Piezo on board!

== IMU ==
=== Tilda::getOrientation ===
returns " ORIENTATION_HELD", "ORIENTATION_RIGHT" (joystick to the right of the screen), "ORIENTATION_HUNG" or "ORIENTATION_LEFT"

== Flash Storage ==
We have 2mb of flash storage, but we're not using it in the main firmware - Please get this working!
== Data: Schedule ==
===Tilda::getDataStore().getSchedule(day, location) ===
== Date: Weather Forecast ==
===Tilda::getDataStore().getWeatherForecast()===
== Radio ==
There's no way of sending messages in the current version of the firmware, sorry :(

== Time ==

=== Tilda::delay(uint16_t delayInMs) === 

Works like Arduino‚Äôs delay(), but is FreeRTOS-safe. It‚Äôs safe to use this function before FreeRTOS has started.

=== tilda::getClock() ===

Returns an instance of https://github.com/MarkusLange/Arduino-Due-RTC-Library/blob/master/rtc_clock.h

==Settings==
===uint16_t tilda::getBadgeId()===


==Battery==
===float TiLDA::getBatteryVoltage()===
Returns the current voltage as a float

===uint8_t TiLDA::getBatteryPercent()===
Returns the current voltage as a percentage

===uint8_t TiLDA::getChargeState()===
Returns the charge state

0 Charging
1 Not Charging</text>
      <sha1>5xfqayqqs3c78vps545ab4o0lyu40rv</sha1>
    </revision>
  </page>
  <page>
    <title>TiLDA MKe/Full Specification</title>
    <ns>0</ns>
    <id>9</id>
    <revision>
      <id>23</id>
      <parentid>22</parentid>
      <timestamp>2015-05-01T16:20:11Z</timestamp>
      <contributor>
        <username>Thinkl33t</username>
        <id>2</id>
      </contributor>
      <origin>23</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1144" sha1="5n5kh4e9qaf5m5ivfmjbg0qf6chhecz" xml:space="preserve">The following hardware has been included on the badge.

* [http://www.atmel.com/products/microcontrollers/arm/sam3x.aspx Atmel ATSAM3X8E]
** This is the same chip as the [http://arduino.cc/en/Main/ArduinoBoardDue Arduino Due] and gives us the base platform for the badge
** 32bit ARM Cortex M3 * 84MHz
** 512KBytes Flash RAM
** 96KBytes of SRAM
* A 128x64 pixel monochrome LCD display
* [http://shop.ciseco.co.uk/srf-wireless-rf-radio-surface-mount/ Ciseco SRF Radio]
** 868Mhz RF Transceiver
** Simple UART interface
** Low power sleep mode
* [http://www.invensense.com/mems/gyro/mpu6050.html MPU-6050] 3-axis Accelerometer and 3-axis gyro
** I2C interface
** Tri-Axis angular rate sensor (gyro) with a sensitivity up to 131 LSBs/dps and a full-scale range of ¬±250, ¬±500, ¬±1000, and ¬±2000dps
** Tri-Axis accelerometer with a programmable full scale range of ¬±2g, ¬±4g, ¬±8g and ¬±16g
** Digital Motion Processing‚Ñ¢ (DMP‚Ñ¢) engine offloads complex MotionFusion, sensor timing synchronisation and gesture detection
* PMIC &amp; LiPo
* Joystick, 4 way with click
* Buttons
* RGB LEDs
* IR Transmitter
* Arduino Headers
* Pads for wearable tech</text>
      <sha1>5n5kh4e9qaf5m5ivfmjbg0qf6chhecz</sha1>
    </revision>
  </page>
  <page>
    <title>UHB-IF</title>
    <ns>0</ns>
    <id>83</id>
    <revision>
      <id>511</id>
      <parentid>509</parentid>
      <timestamp>2024-05-30T20:20:04Z</timestamp>
      <contributor>
        <username>Vishnee</username>
        <id>93</id>
      </contributor>
      <origin>511</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1497" sha1="n1rodduu347w92k289width4ijnljws" xml:space="preserve">The Unnecessary Hexpansion Bureaucracy Implementers Forum (UHB-IF) exists to implement unnecessary hexpansion bureaucracy.

The only way to obtain a Vendor ID to use with hexpansion EEPROMs is via the UHB-IF. You will need a vendor ID to make a valid hexpansion EEPROM header.
UHB-IF makes sure that Vendor IDs used by hexpansions are inconvenient to obtain. To obtain a Vendor ID, fill out the right UHB-IF form. Forms are available from authorized representatives of the UHB-IF. The authorized representative at EMF2024 is the [https://wiki.emfcamp.org/2024/wiki/ScottishConsulate|Scottish Consulate]. To request the right form from the Scottish Consulate, please fill in [https://usercontent.irccloud-cdn.com/file/A6xrTR6Z/Consulate%20Scot%20REQ1.pdf form REQ1] and present it in person to the Scottish Consulate during their posted hours of operation. Some copies of REQ1 might be available at the badge team and/or Scottish Consulate. 
For further information about how the Scottish Consulate handles procedures can be found in [https://scottishconsulate.org/right_link| their wiki]. 

Organizations wishing to use the legacy REQ-9 method of application should contact the authorized representative for further instructions.

[[UHB-IF/Issued IDs]]


In defiance of the UHB-IF, rebel hackers have homesteaded on some vendor IDs. They are linked below:

[[UHB-IF/Uncontrolled IDs]]

The UHB-IF does not approve of unbureaucratic mechanisms like this, but is powerless to do anything about them.</text>
      <sha1>n1rodduu347w92k289width4ijnljws</sha1>
    </revision>
  </page>
  <page>
    <title>UHB-IF/Issued IDs</title>
    <ns>0</ns>
    <id>86</id>
    <revision>
      <id>517</id>
      <parentid>516</parentid>
      <timestamp>2024-06-02T16:52:43Z</timestamp>
      <contributor>
        <username>MatthewWilkes</username>
        <id>69</id>
      </contributor>
      <origin>517</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1289" sha1="0xqsydcu93xhcty7s8hkolh7szab99r" xml:space="preserve">These VIDs are properly issued by the UHB-IF. This may only be edited by authorised representatives of the VID owner.

== VID=0xBAD3 ==
Used by the EMFCamp Badge Team for official hexpansions and frontboards. 
{| class="wikitable" style="margin:auto"
|+ devices with VID=0xBAD3
|-
! PID !! Name !! Description || Author || Link to source
|-
| 0x2400 || TwentyTwentyFour || The frontboard for 2024's badge || Badge Team || 
|}


== VID=0x4291 ==
Used by Matt Wilkes

{| class="wikitable" style="margin:auto"
|+ devices with VID=0x1337
|-
! PID !! Name !! Description || Author || Link to source
|- 
| 0x5e6a || MD Interface || Sega Megadrive Controller Adapter || Matt W || N/A ||
!
|}

== VID=0x0023 ==
Used by Uglyhack

{| class="wikitable" style="margin:auto"
|+ devices with VID=0x0023
|-
! PID !! Name !! Description || Author || Link to source
|- 
| 0x0001 || MCP3021 || MCP3021 board, with EEPROM and potentiometer || Uglyhack ||  
|}

== VID=0x1337 ==
Used by thinkl33t

{| class="wikitable" style="margin:auto"
|+ devices with VID=0x1337
|-
! PID !! Name !! Description || Author || Link to source
|- 
| 0x9009 || Googly Eye || Googly Eye Hexpansion with Pattern Matching || thinkl33t || [https://github.com/emfcamp/badge-2024-addons/tree/main/thinkl33t/googly-eye-hexpansion]  
|}</text>
      <sha1>0xqsydcu93xhcty7s8hkolh7szab99r</sha1>
    </revision>
  </page>
  <page>
    <title>UHB-IF/Uncontrolled IDs</title>
    <ns>0</ns>
    <id>84</id>
    <revision>
      <id>519</id>
      <parentid>518</parentid>
      <timestamp>2024-07-22T21:07:15Z</timestamp>
      <contributor>
        <username>Mich181189</username>
        <id>98</id>
      </contributor>
      <comment>/* VID=0xcafe */ Add 0x1936 for something I'm working on</comment>
      <origin>519</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4040" sha1="eq3r0k346f8mpezsfjf50rtf5j5b4uo" xml:space="preserve">These VIDs were taken over by the hacker community without the [[UHB-IF]]'s permission. As they are in use, there is no way to enforce exclusivity for them, and therefore the UHB-IF cannot assign them to anyone else. They are self-managed by the community using them. Add your hexpansion PID to the list to ensure nobody else uses the same identifiers. Please add in numeric order to make searching easier.

== VID=0xf055 ==
Used for open hardware hexpansions. 
{| class="wikitable" style="margin:auto"
|+ devices with VID=0xf055
|-
! PID !! Name !! Description || Author || Link to source
|-
| 0x0000 || Example1 || This is an example entry || H.Acker || [https://github.com/emfcamp/badge-2024-addons]
|-
| 0x???? || Template || This is a template entry - please edit || YourNickHere || [https://github.com/emfcamp/badge-2024-addons]
|-
| 0x4247 || GCHQ.NET Quest Marker || Quest marker for Great Camp Hexpansion Quest || GCHQ.NET || [https://github.com/gchq-net/hexpansion_hardware]
|-
| 0x8426 || "Legacy" connector adapter || Shitty add-ons? TiDAL projects? I2C sensors? Connect them easy. || dratini0 || [https://github.com/dratini0/legacy-adapter-hexpansion]
|-
| 0x8427 || HUB75 hexpansion || I think the Tildagon can drive an LED wall panel. || dratini0 || [https://github.com/dratini0/hub75-hexpansion]
|-
| 0x9009 || Googly Eye || Googly Eye Hexpansion || thinkl33t || [https://github.com/emfcamp/badge-2024-addons/thinkl33t/]
|}

== VID=0xcafe ==
Used for any kind of hexpansion.
{| class="wikitable" style="margin:auto"
|+ devices with VID=0xcafe
|-
! PID !! Name !! Description || Author || Link/image
|-
| 0x0000 || Example1 || This is an example entry || H.Acker || [https://github.com/emfcamp/badge-2024-addons]
|-
| 0x0191 || Maker Space Badge || The Maker Space logo with LEDs, ducks and rabbits. || Dan Nixon || [https://github.com/DanNixon/hexpansions/tree/main/makerspace-badge]
|-
| 0x0CA7 || Cat ears || Cat ears with neopixels || Rox || tbd
|-
| 0x1936 || (A Very Daft Idea) || Placeholder for something I'm working on - Details soon. Hardware built, just needs some software (unfortunately probably with badge firmware changes) || mich181189 || Coming Soon
|-
| 0x5BAA || Janky Machine|| What even is art, really? || [https://danny.makesthings.work/ walkerdanny] || TBD
|-
| 0x5107 || Solar Panel || Poorly thought through solar range extender || Coral (Correlation) || [https://empty.cafe/@coral/112378355746353006]
|-
| 0x5E6A || MD Interface || Control the badge with SEGA Megadrive 3 button controllers || [[User:MatthewWilkes|Matthew Wilkes]] || TBC
|-
| 0xBEE5 || Nullsector Authenticator || &lt;code&gt;DESCRIPTION REDACTED BY POLYBIUS BIOTECH SECURITY&lt;/code&gt; || [[User:Graham_Sutherland|Graham Sutherland]] || N/A
|-
| 0xCAFF || Caffeine Jitters|| When the second Club Mate hits || [https://danny.makesthings.work/ walkerdanny] || TBD
|-
| 0xCBCA || HexDrive || Dual Motor || [[User:Robotmad|Robotmad]] || [https://github.com/TeamRobotmad/HexDrive]
|-
| 0xCBCB || HexDrive || Dual Motor or 4 Servo Driver (uncommitted) || [[User:Robotmad|Robotmad]] || [https://github.com/TeamRobotmad/HexDrive]
|-
| 0xCBCC || HexDrive || 4 Servo Driver || [[User:Robotmad|Robotmad]] || [https://github.com/TeamRobotmad/HexDrive]
|-
| 0xCBCD || HexDrive || Single Motor and 2 Servo Driver || [[User:Robotmad|Robotmad]] || [https://github.com/TeamRobotmad/HexDrive]
|-
| 0xCBCE || HexSense || Line Sensor Interface || [[User:Robotmad|Robotmad]] || [https://github.com/TeamRobotmad/HexDrive]
|-
| 0xCBCF || HexSense || ToF Range Sensor Interface || [[User:Robotmad|Robotmad]] || [https://github.com/TeamRobotmad/HexDrive]
|-
| 0xD15C || Flopagon || 16MB SPI Flash storage || [https://nathandumont.com Nathan Dumont] || TBD
|-
| 0xDC01 || Omni Wheel || A single motor/encoder with omni wheel || [https://dumont-cybernetics.net Nathan Dumont] || [https://github.com/hairymnstr/omni-wheel-hexpansion]
|-
| 0x???? || Template || This is a template entry - please edit || YourNickHere || [https://github.com/emfcamp/badge-2024-addons]
|}</text>
      <sha1>eq3r0k346f8mpezsfjf50rtf5j5b4uo</sha1>
    </revision>
  </page>
</mediawiki>
